{"files":[{"path":["/","home","runner","work","serde_sexpr","serde_sexpr","src","de","error.rs"],"content":"use serde::de;\nuse std::fmt::Display;\nuse thiserror::Error;\n\n#[derive(Clone, Debug, Error, PartialEq)]\npub enum Error {\n\t#[error(\"{0}\")]\n\tMessage(String),\n\n\t/// This error will be returned if you request to deserialize anything but a struct at root\n\t/// level.\n\t#[error(\"Expected to deserialize a struct at root level\")]\n\tExpectedStruct,\n\n\t/// This error will be returned if the input ends unexpectedly.\n\t#[error(\"Unexpected end of input\")]\n\tEof,\n\n\t/// This error will be returned if an opening s-expr was expected, but some other token was\n\t/// found.\n\t#[error(\"Expected s-expr\")]\n\tExpectedSExpr,\n\n\t/// This error will be returned if an opening s-expr with a certain name was expected, but\n\t/// some other token was found.\n\t#[error(\"Expected s-expr identifier {0}\")]\n\tExpectedSExprIdentifier(&'static str),\n\n\t/// This error will be returned if the end of the s-expr was expected, but some other token\n\t/// was found.\n\t#[error(\"Expected end of expression\")]\n\tExpectedEoe,\n\n\t/// This error will be returned if an identifier was expected, but some other token was found.\n\t#[error(\"Expected identifier\")]\n\tExpectedIdentifier,\n\n\t/// This error will be returned if a number was expected, but some other token was found.\n\t#[error(\"Expected number\")]\n\tExpectedNumber,\n\n\t/// This error will be returned if a string was expected, but some other token was found.\n\t#[error(\"Expected string\")]\n\tExpectedString,\n\n\t/// This error will be returned if an option was requested. [`Option`] is **not supported**\n\t/// by this data format.\n\t#[error(\"std::option::Option cannot be deserialized by this data format\")]\n\tDeserializeOption,\n\n\t/// This error will be returned if an s-expr is found, but its name (and fields) were not\n\t/// supplied to the deserializer (e.g. `deserialize_any` was called).\n\t#[error(\"Missing s-expr type info\")]\n\tMissingSExprInfo,\n\n\t/// This error will be returned when attempting to deserialize a non-unit enum variant.\n\t#[error(\"Non-unit enum variants are not supported\")]\n\tNonUnitEnumVariant,\n\n\t/// This error will be returned if there were trailing tokens after the deserialization\n\t/// finished.\n\t#[error(\"Trailing tokens\")]\n\tTrailingTokens\n}\n\nimpl de::Error for Error {\n\tfn custom<T: Display>(msg: T) -> Self {\n\t\tSelf::Message(msg.to_string())\n\t}\n}\n","traces":[{"line":67,"address":[249056,249121],"length":1,"stats":{"Line":1},"fn_name":"custom<core::fmt::Arguments>"},{"line":68,"address":[249069],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","serde_sexpr","serde_sexpr","src","de","mod.rs"],"content":"use paste::paste;\nuse serde::{\n\tde::{self, DeserializeSeed, EnumAccess, MapAccess, SeqAccess, VariantAccess, Visitor},\n\tforward_to_deserialize_any, Deserialize\n};\nuse std::{borrow::Cow, fmt::Display, str::FromStr};\n\nmod error;\npub use error::Error;\n\npub struct Deserializer<'de> {\n\tinput: &'de str\n}\n\nimpl<'de> Deserializer<'de> {\n\tpub fn from_str(input: &'de str) -> Self {\n\t\tSelf { input }\n\t}\n}\n\ntype Result<T, E = Error> = std::result::Result<T, E>;\n\npub fn from_str<'de, T>(input: &'de str) -> Result<T>\nwhere\n\tT: Deserialize<'de>\n{\n\tlet mut deserializer = Deserializer::from_str(input);\n\tlet value = T::deserialize(&mut deserializer)?;\n\n\tdeserializer.skip_whitespace();\n\tif !deserializer.input.is_empty() {\n\t\treturn Err(Error::TrailingTokens);\n\t}\n\n\tOk(value)\n}\n\nimpl<'de> Deserializer<'de> {\n\tfn skip_whitespace(&mut self) {\n\t\tself.input = self.input.trim_start();\n\t}\n\n\tfn peek_char(&mut self) -> Result<char> {\n\t\tself.input.chars().next().ok_or(Error::Eof)\n\t}\n\n\tfn next_char(&mut self) -> Result<char> {\n\t\tlet ch = self.peek_char()?;\n\t\tself.input = &self.input[ch.len_utf8()..];\n\t\tOk(ch)\n\t}\n\n\tfn peek_identifier(&mut self) -> Option<&'de str> {\n\t\tlet len: usize = self\n\t\t\t.input\n\t\t\t.chars()\n\t\t\t.take_while(|ch| ch.is_ascii_alphabetic() || *ch == '_')\n\t\t\t.map(|ch| ch.len_utf8())\n\t\t\t.sum();\n\t\tif len == 0 {\n\t\t\treturn None;\n\t\t}\n\t\tSome(&self.input[..len])\n\t}\n\n\tfn peek_sexpr_identifier(&mut self) -> Result<&'de str> {\n\t\tlet mut chars = self.input.chars();\n\t\tif chars.next().ok_or(Error::Eof)? != '(' {\n\t\t\treturn Err(Error::ExpectedSExpr);\n\t\t}\n\t\tlet paren = '('.len_utf8();\n\t\tlet len: usize = chars\n\t\t\t.take_while(|ch| ch.is_ascii_alphabetic() || *ch == '_')\n\t\t\t.map(|ch| ch.len_utf8())\n\t\t\t.sum();\n\t\tif len == 0 {\n\t\t\treturn Err(Error::ExpectedIdentifier);\n\t\t}\n\t\tOk(&self.input[paren..paren + len])\n\t}\n\n\tfn consume(&mut self, len: usize) -> Result<()> {\n\t\tif self.input.len() < len {\n\t\t\treturn Err(Error::Eof);\n\t\t}\n\t\tself.input = &self.input[len..];\n\t\tOk(())\n\t}\n\n\tfn parse_number<T>(&mut self) -> Result<T>\n\twhere\n\t\tT: FromStr,\n\t\tT::Err: Display\n\t{\n\t\tlet len = self\n\t\t\t.input\n\t\t\t.chars()\n\t\t\t.take_while(|ch| ch.is_ascii_digit() || *ch == '-' || *ch == '.')\n\t\t\t.map(|ch| ch.len_utf8())\n\t\t\t.sum();\n\t\tif len == 0 {\n\t\t\treturn Err(Error::ExpectedNumber);\n\t\t}\n\t\tlet number = &self.input[..len];\n\t\tlet number = number\n\t\t\t.parse()\n\t\t\t.map_err(|err: T::Err| Error::Message(err.to_string()))?;\n\t\tself.input = &self.input[len..];\n\t\tOk(number)\n\t}\n\n\tfn parse_string(&mut self) -> Result<Cow<'de, str>> {\n\t\tmatch self.peek_char()? {\n\t\t\t'(' => Err(Error::ExpectedString),\n\n\t\t\t'\"' => {\n\t\t\t\tself.consume('\"'.len_utf8())?;\n\t\t\t\tlet mut value = String::new();\n\t\t\t\tloop {\n\t\t\t\t\tlet len: usize = self\n\t\t\t\t\t\t.input\n\t\t\t\t\t\t.chars()\n\t\t\t\t\t\t.take_while(|ch| *ch != '\"')\n\t\t\t\t\t\t.map(|ch| ch.len_utf8())\n\t\t\t\t\t\t.sum();\n\t\t\t\t\tif len >= self.input.len() {\n\t\t\t\t\t\treturn Err(Error::Eof);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet mut start_idx = value.chars().count();\n\t\t\t\t\tvalue += &self.input[..len + 1];\n\t\t\t\t\tself.input = &self.input[len + 1..];\n\t\t\t\t\twhile let Some(idx) = (&value[start_idx..]).find(r\"\\\\\") {\n\t\t\t\t\t\tlet idx = start_idx + idx;\n\t\t\t\t\t\tvalue.replace_range(idx..idx + 2, r\"\\\");\n\t\t\t\t\t\tstart_idx = idx + 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif value.ends_with(r#\"\\\"\"#) && start_idx < value.len() - 1 {\n\t\t\t\t\t\tvalue.remove(value.len() - 2);\n\t\t\t\t\t} else if value.ends_with(r#\"\"\"#) {\n\t\t\t\t\t\tvalue.remove(value.len() - 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunreachable!();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tOk(value.into())\n\t\t\t},\n\n\t\t\t_ => {\n\t\t\t\tlet len = self\n\t\t\t\t\t.input\n\t\t\t\t\t.chars()\n\t\t\t\t\t.take_while(|ch| !ch.is_ascii_whitespace() && *ch != ')')\n\t\t\t\t\t.map(|ch| ch.len_utf8())\n\t\t\t\t\t.sum();\n\t\t\t\tif len == 0 {\n\t\t\t\t\treturn Err(Error::Eof);\n\t\t\t\t}\n\t\t\t\tlet value = &self.input[..len];\n\t\t\t\tself.input = &self.input[len..];\n\t\t\t\tOk(value.into())\n\t\t\t}\n\t\t}\n\t}\n}\n\nimpl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n\ttype Error = Error;\n\n\tfn deserialize_any<V>(self, _: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\treturn Err(Error::ExpectedStruct);\n\t}\n\n\tfn deserialize_struct<V>(\n\t\tself,\n\t\tname: &'static str,\n\t\tfields: &'static [&'static str],\n\t\tvisitor: V\n\t) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_map(SExpr::new(self, name, fields)?)\n\t}\n\n\tfn deserialize_unit_struct<V>(self, name: &'static str, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tSExpr::consume_beginning(self, name)?;\n\t\tif self.next_char()? != ')' {\n\t\t\treturn Err(Error::ExpectedEoe);\n\t\t}\n\t\tvisitor.visit_unit()\n\t}\n\n\tfn deserialize_newtype_struct<V>(self, name: &'static str, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_seq(SExprTuple::new(self, name)?)\n\t}\n\n\tfn deserialize_tuple_struct<V>(\n\t\tself,\n\t\tname: &'static str,\n\t\t_len: usize,\n\t\tvisitor: V\n\t) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_seq(SExprTuple::new(self, name)?)\n\t}\n\n\tforward_to_deserialize_any! {\n\t\tbool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n\t\tbytes byte_buf option unit seq tuple map enum identifier ignored_any\n\t}\n}\n\n/// Deserialise an s-expr.\nstruct SExpr<'a, 'de> {\n\tde: &'a mut Deserializer<'de>,\n\tfields: &'static [&'static str],\n\tindex: usize,\n\tskip_to: Option<usize>\n}\n\nimpl<'a, 'de> SExpr<'a, 'de> {\n\tfn consume_beginning(de: &mut Deserializer<'de>, name: &'static str) -> Result<()> {\n\t\tde.skip_whitespace();\n\t\tif de.peek_sexpr_identifier()? != name {\n\t\t\treturn Err(Error::ExpectedSExprIdentifier(name));\n\t\t}\n\t\tde.consume(name.len() + '('.len_utf8())?;\n\t\tOk(())\n\t}\n\n\tfn new(\n\t\tde: &'a mut Deserializer<'de>,\n\t\tname: &'static str,\n\t\tfields: &'static [&'static str]\n\t) -> Result<Self> {\n\t\tSelf::consume_beginning(de, name)?;\n\t\tOk(Self {\n\t\t\tde,\n\t\t\tfields,\n\t\t\tindex: 0,\n\t\t\tskip_to: None\n\t\t})\n\t}\n\n\tfn check_eoe(&mut self) -> Result<()> {\n\t\tself.de.skip_whitespace();\n\t\tif self.skip_to.is_none() && self.de.peek_char()? == ')' {\n\t\t\tself.de.consume(1)?;\n\t\t\t// technically we're done, but there could be booleans that are false, so we'll\n\t\t\t// deserialize those as None/false eventhough they don't exist in the input.\n\t\t\tself.skip_to = Some(self.index + 1);\n\t\t}\n\t\tOk(())\n\t}\n\n\tfn next_value_seed_impl<T>(&mut self, seed: T) -> Result<T::Value>\n\twhere\n\t\tT: DeserializeSeed<'de>\n\t{\n\t\tif self.index >= self.fields.len() {\n\t\t\tpanic!(\"There was no key and there is no value\");\n\t\t}\n\n\t\t// booleans are represented in this weird way where they are simply missing if they are\n\t\t// false. This means that if we detect a boolean ahead of our current index, we'll assume\n\t\t// everything inbetween is either None or false, and skip ahead.\n\t\tif let Some(skip_to) = self.skip_to {\n\t\t\tif skip_to == self.index {\n\t\t\t\tself.skip_to = None;\n\t\t\t\treturn seed.deserialize(TrueField);\n\t\t\t}\n\t\t\treturn seed.deserialize(MissingField);\n\t\t}\n\t\tif let Some(identifier) = self.de.peek_identifier() {\n\t\t\tif self.fields[self.index] == identifier {\n\t\t\t\tself.de.consume(identifier.len())?;\n\t\t\t\treturn seed.deserialize(TrueField);\n\t\t\t}\n\t\t\tfor i in self.index + 1..self.fields.len() {\n\t\t\t\tif self.fields[i] == identifier {\n\t\t\t\t\tself.de.consume(identifier.len())?;\n\t\t\t\t\tself.skip_to = Some(i);\n\t\t\t\t\treturn seed.deserialize(MissingField);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tseed.deserialize(Field::new(self.de, Some(self.fields[self.index])))\n\t}\n}\n\nimpl<'a, 'de> MapAccess<'de> for SExpr<'a, 'de> {\n\ttype Error = Error;\n\n\tfn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>>\n\twhere\n\t\tK: DeserializeSeed<'de>\n\t{\n\t\tself.check_eoe()?;\n\t\tif self.index >= self.fields.len() {\n\t\t\treturn Ok(None);\n\t\t}\n\t\tseed.deserialize(FieldIdent(self.fields[self.index]))\n\t\t\t.map(Some)\n\t}\n\n\tfn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value>\n\twhere\n\t\tT: DeserializeSeed<'de>\n\t{\n\t\tlet value = self.next_value_seed_impl(seed)?;\n\t\tself.index += 1;\n\t\tself.check_eoe()?;\n\t\tOk(value)\n\t}\n}\n\n/// Deserialize an s-expr in tuple format. It cannot contain booleans.\nstruct SExprTuple<'a, 'de> {\n\tde: &'a mut Deserializer<'de>,\n\tend: bool\n}\n\nimpl<'a, 'de> SExprTuple<'a, 'de> {\n\tfn new(de: &'a mut Deserializer<'de>, name: &'static str) -> Result<Self> {\n\t\tSExpr::consume_beginning(de, name)?;\n\t\tOk(Self { de, end: false })\n\t}\n\n\tfn check_eoe(&mut self) -> Result<()> {\n\t\tif self.end {\n\t\t\treturn Ok(());\n\t\t}\n\n\t\tself.de.skip_whitespace();\n\t\tif self.de.peek_char()? == ')' {\n\t\t\tself.de.consume(')'.len_utf8())?;\n\t\t\tself.end = true;\n\t\t}\n\t\tOk(())\n\t}\n}\n\nimpl<'a, 'de> SeqAccess<'de> for SExprTuple<'a, 'de> {\n\ttype Error = Error;\n\n\tfn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>\n\twhere\n\t\tT: DeserializeSeed<'de>\n\t{\n\t\tself.check_eoe()?;\n\t\tif self.end {\n\t\t\treturn Ok(None);\n\t\t}\n\t\tlet value = seed.deserialize(Field::new(self.de, None))?;\n\t\tself.check_eoe()?;\n\t\tOk(Some(value))\n\t}\n}\n\n/// Deserialize a field's ident.\nstruct FieldIdent(&'static str);\n\nimpl<'de> de::Deserializer<'de> for FieldIdent {\n\ttype Error = Error;\n\n\tfn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_borrowed_str(self.0)\n\t}\n\n\tforward_to_deserialize_any! {\n\t\tbool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n\t\tbytes byte_buf option unit unit_struct newtype_struct seq tuple\n\t\ttuple_struct map struct enum identifier ignored_any\n\t}\n}\n\n/// Deserialize a single boolean with value `true`.\nstruct TrueField;\n\nimpl<'de> de::Deserializer<'de> for TrueField {\n\ttype Error = Error;\n\n\tfn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_bool(true)\n\t}\n\n\tforward_to_deserialize_any! {\n\t\tbool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n\t\tbytes byte_buf option unit unit_struct newtype_struct seq tuple\n\t\ttuple_struct map struct enum identifier ignored_any\n\t}\n}\n\n/// Deserialize either a boolean with value `false` or an option with value `None`.\nstruct MissingField;\n\nimpl<'de> de::Deserializer<'de> for MissingField {\n\ttype Error = Error;\n\n\tfn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_none()\n\t}\n\n\tfn deserialize_bool<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_bool(false)\n\t}\n\n\tforward_to_deserialize_any! {\n\t\ti8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n\t\tbytes byte_buf option unit unit_struct newtype_struct seq tuple\n\t\ttuple_struct map struct enum identifier ignored_any\n\t}\n}\n\n/// A field whose value does not match its ident. This means that if a boolean gets requested,\n/// we must return false without touching the input.\n///\n/// We still store the ident if we know it, so that we can parse a sequence like\n/// (<ident> <values..>).\nstruct Field<'a, 'de> {\n\tde: &'a mut Deserializer<'de>,\n\tident: Option<&'static str>\n}\n\nimpl<'a, 'de> Field<'a, 'de> {\n\tfn new(de: &'a mut Deserializer<'de>, ident: Option<&'static str>) -> Self {\n\t\tSelf { de, ident }\n\t}\n}\n\nmacro_rules! forward_to_parse_number {\n\t($($ident:ident)+) => {\n\t\t$(\n\t\t\tpaste! {\n\t\t\t\tfn [<deserialize_ $ident>]<V>(self, visitor: V) -> Result<V::Value>\n\t\t\t\twhere\n\t\t\t\t\tV: Visitor<'de>\n\t\t\t\t{\n\t\t\t\t\tvisitor.[<visit_ $ident>](self.de.parse_number()?)\n\t\t\t\t}\n\t\t\t}\n\t\t)+\n\t};\n}\n\nimpl<'a, 'de> de::Deserializer<'de> for Field<'a, 'de> {\n\ttype Error = Error;\n\n\tfn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tmatch self.de.peek_char()? {\n\t\t\tch @ '0'..='9' | ch @ '-' | ch @ '.' => match self.de.input.find('.') {\n\t\t\t\tSome(idx)\n\t\t\t\t\tif (&self.de.input[..idx]).contains(|ch: char| ch.is_ascii_whitespace()) =>\n\t\t\t\t{\n\t\t\t\t\tif ch == '-' {\n\t\t\t\t\t\tself.deserialize_i64(visitor)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.deserialize_u64(visitor)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t_ => self.deserialize_f32(visitor)\n\t\t\t},\n\t\t\t'(' if Some(self.de.peek_sexpr_identifier()?) == self.ident => {\n\t\t\t\tself.deserialize_seq(visitor)\n\t\t\t},\n\t\t\t'(' => Err(Error::MissingSExprInfo),\n\t\t\t_ => self.deserialize_string(visitor)\n\t\t}\n\t}\n\n\tfn deserialize_bool<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_bool(false)\n\t}\n\n\tfn deserialize_str<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tself.deserialize_string(visitor)\n\t}\n\n\tfn deserialize_string<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tlet value = self.de.parse_string()?;\n\t\tmatch value {\n\t\t\tCow::Borrowed(value) => visitor.visit_borrowed_str(value),\n\t\t\tCow::Owned(value) => visitor.visit_string(value)\n\t\t}\n\t}\n\n\tfn deserialize_option<V>(self, _visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\t// we'll need to know the type of Some (i.e. the s-expr tag) to see if it is present in\n\t\t// the input or not\n\t\t// however, serde doesn't give us this type of information, so we'll just error\n\t\treturn Err(Error::DeserializeOption);\n\t}\n\n\tfn deserialize_struct<V>(\n\t\tself,\n\t\tname: &'static str,\n\t\tfields: &'static [&'static str],\n\t\tvisitor: V\n\t) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_map(SExpr::new(self.de, name, fields)?)\n\t}\n\n\tfn deserialize_unit_struct<V>(self, name: &'static str, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tSExpr::consume_beginning(self.de, name)?;\n\t\tif self.de.next_char()? != ')' {\n\t\t\treturn Err(Error::ExpectedEoe);\n\t\t}\n\t\tvisitor.visit_unit()\n\t}\n\n\tfn deserialize_newtype_struct<V>(self, name: &'static str, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_seq(SExprTuple::new(self.de, name)?)\n\t}\n\n\tfn deserialize_tuple_struct<V>(\n\t\tself,\n\t\tname: &'static str,\n\t\t_len: usize,\n\t\tvisitor: V\n\t) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_seq(SExprTuple::new(self.de, name)?)\n\t}\n\n\tfn deserialize_enum<V>(\n\t\tself,\n\t\t_name: &'static str,\n\t\t_variants: &'static [&'static str],\n\t\tvisitor: V\n\t) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_enum(self)\n\t}\n\n\tfn deserialize_seq<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tlet ident = self.ident.ok_or(Error::MissingSExprInfo)?;\n\t\tvisitor.visit_seq(SExprTuple::new(self.de, ident)?)\n\t}\n\n\tfn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tself.deserialize_seq(visitor)\n\t}\n\n\tforward_to_parse_number! {\n\t\ti8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64\n\t}\n\n\tforward_to_deserialize_any! {\n\t\tchar bytes byte_buf unit map identifier ignored_any\n\t}\n}\n\nimpl<'a, 'de> EnumAccess<'de> for Field<'a, 'de> {\n\ttype Error = Error;\n\ttype Variant = UnitVariant;\n\n\tfn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant)>\n\twhere\n\t\tV: DeserializeSeed<'de>\n\t{\n\t\tOk((seed.deserialize(self)?, UnitVariant))\n\t}\n}\n\n/// This will deserialize only unit variants.\nstruct UnitVariant;\n\nimpl<'de> VariantAccess<'de> for UnitVariant {\n\ttype Error = Error;\n\n\tfn unit_variant(self) -> Result<()> {\n\t\tOk(())\n\t}\n\n\tfn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value>\n\twhere\n\t\tT: DeserializeSeed<'de>\n\t{\n\t\tErr(Error::NonUnitEnumVariant)\n\t}\n\n\tfn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tErr(Error::NonUnitEnumVariant)\n\t}\n\n\tfn struct_variant<V>(self, _fields: &'static [&'static str], _visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tErr(Error::NonUnitEnumVariant)\n\t}\n}\n","traces":[{"line":16,"address":[238576],"length":1,"stats":{"Line":2},"fn_name":"from_str"},{"line":23,"address":[376768,373792,377164,375492,374336,375072,374200,374902,376116,376670,375696,376320],"length":1,"stats":{"Line":6},"fn_name":"from_str<test::Size>"},{"line":27,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[238624],"length":1,"stats":{"Line":2},"fn_name":"skip_whitespace"},{"line":40,"address":[238641],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[238704],"length":1,"stats":{"Line":2},"fn_name":"peek_char"},{"line":44,"address":[238723],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[238800],"length":1,"stats":{"Line":1},"fn_name":"next_char"},{"line":48,"address":[238830,238934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[239093,238897],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[239162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[239184],"length":1,"stats":{"Line":1},"fn_name":"peek_identifier"},{"line":54,"address":[239204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[210846,210816],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":58,"address":[210912,210936],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":60,"address":[239289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[239295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[239316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[239392],"length":1,"stats":{"Line":2},"fn_name":"peek_sexpr_identifier"},{"line":67,"address":[239422],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[239444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[239738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[239708],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[239807],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[210960,210990],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":74,"address":[211080,211056],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":76,"address":[239882],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[239893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[239980],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[240160],"length":1,"stats":{"Line":2},"fn_name":"consume"},{"line":83,"address":[240194],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[240282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[240236,240356],"length":1,"stats":{"Line":4},"fn_name":null},{"line":87,"address":[240363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[346928,346208,347680,346179,345456,348365,347651,346904],"length":1,"stats":{"Line":3},"fn_name":"parse_number<i64>"},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":112,"address":[240384,243482],"length":1,"stats":{"Line":2},"fn_name":"parse_string"},{"line":113,"address":[240423],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[240736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[241314,240808,241400],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[241374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[241546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[241562,241680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[211104,211117],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":124,"address":[211160,211136],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":126,"address":[241734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[241816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[241785,241942],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[242028],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[242219],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[243444,242395],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[243242,243268,242567],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[243314,243250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[243449,243415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[243095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[240698,240847],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[211214,211184],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":156,"address":[211280,211304],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}"},{"line":158,"address":[240918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[240932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[241020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[241119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[241217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[412464,412607,413039,412896,413328,413471],"length":1,"stats":{"Line":3},"fn_name":"deserialize_struct<test::_::{impl#0}::deserialize::__Visitor>"},{"line":188,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":191,"address":[413760,414336],"length":1,"stats":{"Line":1},"fn_name":"deserialize_unit_struct<test::_::{impl#0}::deserialize::__Visitor>"},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":202,"address":[414831,414704,414368,414495],"length":1,"stats":{"Line":2},"fn_name":"deserialize_newtype_struct<test::_::{impl#0}::deserialize::__Visitor>"},{"line":206,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[243520],"length":1,"stats":{"Line":2},"fn_name":"consume_beginning"},{"line":237,"address":[243568],"length":1,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[243578,243839],"length":1,"stats":{"Line":4},"fn_name":null},{"line":239,"address":[243872],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[243845,243962,244124],"length":1,"stats":{"Line":4},"fn_name":null},{"line":242,"address":[244107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[244272],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":250,"address":[244534,244343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[244425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[244413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[244672],"length":1,"stats":{"Line":1},"fn_name":"check_eoe"},{"line":260,"address":[244702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[245306,244973,244715],"length":1,"stats":{"Line":3},"fn_name":null},{"line":262,"address":[245106,244999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[245072,245262,245311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[244985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[355612,353596,365728,367744,371740,371776,357628,349600,359644,361696,363712,363676,367708,365692,369760,355648,353632,351616,357664,351580,359680,369724,373756,361660],"length":1,"stats":{"Line":11},"fn_name":"next_value_seed_impl<core::marker::PhantomData<test::PadType>>"},{"line":274,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":309,"address":[380288,380912,379040,379072,378448,380320,379696,379664],"length":1,"stats":{"Line":4},"fn_name":"next_key_seed<core::marker::PhantomData<test::_::{impl#0}::deserialize::__Field>>"},{"line":313,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[382264,385376,385968,387382,385943,387408,388000,388510,381647,382888,380944,381664,383483,383504,386727,382912,387975,384144,385351,386752,384766,384116,384784,382288],"length":1,"stats":{"Line":11},"fn_name":"next_value_seed<core::marker::PhantomData<alloc::vec::Vec<alloc::string::String, alloc::alloc::Global>>>"},{"line":325,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":339,"address":[245344],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":340,"address":[245389,245501],"length":1,"stats":{"Line":2},"fn_name":null},{"line":341,"address":[245446],"length":1,"stats":{"Line":2},"fn_name":null},{"line":344,"address":[245616],"length":1,"stats":{"Line":2},"fn_name":"check_eoe"},{"line":345,"address":[245646],"length":1,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[245672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[245657],"length":1,"stats":{"Line":2},"fn_name":null},{"line":350,"address":[245697,246022],"length":1,"stats":{"Line":3},"fn_name":null},{"line":351,"address":[246029,245953,245903],"length":1,"stats":{"Line":2},"fn_name":null},{"line":352,"address":[246018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[245932],"length":1,"stats":{"Line":2},"fn_name":null},{"line":361,"address":[409200,410328,407984,407944,409159,407056],"length":1,"stats":{"Line":2},"fn_name":"next_element_seed<core::marker::PhantomData<serde::de::ignored_any::IgnoredAny>>"},{"line":365,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":381,"address":[411312,411408,411360,411264],"length":1,"stats":{"Line":4},"fn_name":"deserialize_any<test::_::{impl#0}::deserialize::__FieldVisitor>"},{"line":385,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":401,"address":[410736,410640,410512,410544,410432,410768,410480,410368,410592,410704,410672,410400],"length":1,"stats":{"Line":1},"fn_name":"deserialize_any<test::_::{impl#0}::deserialize::__Visitor>"},{"line":405,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[411776,411808,411872,411680,411904,411648,411936,411840,411712,411968,411744],"length":1,"stats":{"Line":2},"fn_name":"deserialize_any<serde::de::impls::{impl#19}::deserialize::VecVisitor<alloc::string::String>>"},{"line":425,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":428,"address":[412128],"length":1,"stats":{"Line":0},"fn_name":"deserialize_bool<serde::de::impls::BoolVisitor>"},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[246176],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":462,"address":[397552,396149,397366,401382,396790,395136,402144,394915,394597,401856,396468,396352,394496,395845,396048,396976,395440,401280,401958,395744,397264,396688,397654,397078,402246,394800,395541,401568,395237,401670],"length":1,"stats":{"Line":4},"fn_name":"deserialize_f32<serde::de::ignored_any::IgnoredAny>"},{"line":466,"address":[401973,396483,395413,397259,396992,395152,402261,394512,395456,396971,397825,395860,396704,397835,401296,395556,401685,394930,402417,396031,394783,395423,396661,401872,396335,396961,394773,401841,397537,395760,396064,396325,395717,397249,401851,402129,397568,397669,395107,396164,396021,396382,402427,394612,401584,401563,402160,397381,402139,396805,397547,396671,395117,397093,394830,401397,395252,401553,397280,395727],"length":1,"stats":{"Line":8},"fn_name":null},{"line":476,"address":[390400,389104,391676,391712,394280,390376,393008,392980],"length":1,"stats":{"Line":3},"fn_name":"deserialize_any<test::_::{impl#0}::deserialize::__FieldVisitor>"},{"line":480,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":501,"address":[402432],"length":1,"stats":{"Line":1},"fn_name":"deserialize_bool<serde::de::impls::BoolVisitor>"},{"line":505,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[404400,404992,402624,403786,404378,403194,403216,403808,404970,405562],"length":1,"stats":{"Line":4},"fn_name":"deserialize_string<serde::__private::de::content::ContentVisitor>"},{"line":519,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[406586,405584,406032,405745,406170,406448],"length":1,"stats":{"Line":3},"fn_name":"deserialize_struct<serde_sexpr::option::OptionVisitor<test::_::{impl#0}::deserialize::__Visitor>>"},{"line":545,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[402464,402544],"length":1,"stats":{"Line":2},"fn_name":"deserialize_enum<test::_::{impl#0}::deserialize::__Visitor>"},{"line":587,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":590,"address":[398528,400568,398504,397840,400592,399880,399216,399192,401256,399904],"length":1,"stats":{"Line":1},"fn_name":"deserialize_seq<serde::de::ignored_any::IgnoredAny>"},{"line":594,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[388816,388528],"length":1,"stats":{"Line":2},"fn_name":"variant_seed<core::marker::PhantomData<test::_::{impl#0}::deserialize::__Field>>"},{"line":622,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":632,"address":[246224],"length":1,"stats":{"Line":1},"fn_name":"unit_variant"},{"line":633,"address":[246228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":167,"coverable":213},{"path":["/","home","runner","work","serde_sexpr","serde_sexpr","src","lib.rs"],"content":"#![warn(rust_2018_idioms, unreachable_pub)]\n#![forbid(unsafe_code)]\n\nmod literal;\nmod option;\n\npub mod de;\npub mod ser;\n\npub use de::from_str;\npub use literal::Literal;\npub use option::{deserialize_option, OptionDef as Option};\npub use ser::{to_string, to_string_pretty};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","serde_sexpr","serde_sexpr","src","literal.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt::{self, Debug, Display, Formatter};\n\n#[derive(Clone, Eq, Deserialize, PartialEq, Serialize)]\n#[serde(untagged)]\nenum LiteralImp {\n\tNumber(u16),\n\tText(String)\n}\n\n#[derive(Clone, Eq, Deserialize, PartialEq, Serialize)]\n#[serde(transparent)]\npub struct Literal(LiteralImp);\n\nimpl Debug for Literal {\n\tfn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n\t\tmatch &self.0 {\n\t\t\tLiteralImp::Number(num) => Debug::fmt(num, f),\n\t\t\tLiteralImp::Text(text) => Debug::fmt(text, f)\n\t\t}\n\t}\n}\n\nimpl Display for Literal {\n\tfn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n\t\tmatch &self.0 {\n\t\t\tLiteralImp::Number(num) => Display::fmt(num, f),\n\t\t\tLiteralImp::Text(text) => Display::fmt(text, f)\n\t\t}\n\t}\n}\n\nimpl From<u16> for Literal {\n\tfn from(num: u16) -> Self {\n\t\tSelf(LiteralImp::Number(num))\n\t}\n}\n\nimpl From<&str> for Literal {\n\tfn from(text: &str) -> Self {\n\t\ttext.to_owned().into()\n\t}\n}\n\nimpl From<String> for Literal {\n\tfn from(text: String) -> Self {\n\t\tSelf(LiteralImp::Text(text))\n\t}\n}\n","traces":[{"line":16,"address":[162576],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":17,"address":[162594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[162625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[162656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[162704],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":26,"address":[162722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[162753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[162785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[162832],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":35,"address":[162847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[162912],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":41,"address":[162935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[162976],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":47,"address":[162983],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":14},{"path":["/","home","runner","work","serde_sexpr","serde_sexpr","src","option.rs"],"content":"use serde::{\n\tde::{self, Deserialize, Deserializer, EnumAccess, MapAccess, SeqAccess, Visitor},\n\tser::{Serialize, Serializer}\n};\nuse std::{\n\tfmt::{self, Formatter},\n\tmarker::PhantomData\n};\n\n/// Deserialize an [`Option`] in a way that is supported by the s-expression format.\n///\n/// ### Example\n///\n/// ```rust\n/// # use serde::{Deserialize, Serialize};\n/// # #[derive(Debug, PartialEq)]\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(rename = \"size\")]\n/// struct Size(f32, f32);\n///\n/// # #[derive(Debug, PartialEq)]\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(rename = \"thickness\")]\n/// struct Thickness(f32);\n///\n/// # #[derive(Debug, PartialEq)]\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(rename = \"font\")]\n/// struct Font {\n/// \tsize: Size,\n///\n/// \t// This attribute enables our custom deserialize logic.\n/// \t#[serde(with = \"serde_sexpr::Option\")]\n/// \tthickness: Option<Thickness>,\n///\n/// \tbold: bool\n/// }\n/// # assert_eq!(\n/// # \tserde_sexpr::from_str::<Font>(\"(font (size 1 1) bold)\").unwrap(),\n/// # \tFont { size: Size(1.0, 1.0), thickness: None, bold: true }\n/// # );\n/// ```\n///\n/// ### Description\n///\n/// For a more detailed description, see [`deserialize_option`].\npub struct OptionDef<T>(PhantomData<T>);\n\nimpl<'de, T> OptionDef<T>\nwhere\n\tT: Deserialize<'de>\n{\n\tpub fn deserialize<D>(deserializer: D) -> Result<Option<T>, D::Error>\n\twhere\n\t\tD: Deserializer<'de>\n\t{\n\t\tdeserialize_option(deserializer)\n\t}\n}\n\nimpl<T> OptionDef<T>\nwhere\n\tOption<T>: Serialize\n{\n\tpub fn serialize<S>(this: &Option<T>, serializer: S) -> Result<S::Ok, S::Error>\n\twhere\n\t\tS: Serializer\n\t{\n\t\tthis.serialize(serializer)\n\t}\n}\n\n/// Deserialize an [`Option`] in a way that is supported by the s-expression format.\n///\n/// ### Example\n///\n/// ```rust\n/// # use serde::{Deserialize, Serialize};\n/// # #[derive(Debug, PartialEq)]\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(rename = \"size\")]\n/// struct Size(f32, f32);\n///\n/// # #[derive(Debug, PartialEq)]\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(rename = \"thickness\")]\n/// struct Thickness(f32);\n///\n/// # #[derive(Debug, PartialEq)]\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(rename = \"font\")]\n/// struct Font {\n/// \tsize: Size,\n///\n/// \t// This attribute enables our custom deserialize logic.\n/// \t#[serde(deserialize_with = \"serde_sexpr::deserialize_option\")]\n/// \tthickness: Option<Thickness>,\n///\n/// \tbold: bool\n/// }\n/// # assert_eq!(\n/// # \tserde_sexpr::from_str::<Font>(\"(font (size 1 1) bold)\").unwrap(),\n/// # \tFont { size: Size(1.0, 1.0), thickness: None, bold: true }\n/// # );\n/// ```\n///\n/// ### Description\n///\n/// The s-expression format is not only not self-describing, but also does not provide any way\n/// to see if a value is \"missing\" (i.e. [`None`]) without knowing its type. Unfortunately, serde\n/// expects us to decide if the value is present before we know its type: In the above example,\n/// we have the input string `\"bold)\"` and need to know if `thickness` is present or not, without\n/// knowing that `thickness` is an s-expr and not, say, an enum that has a variant called `bold`.\n///\n/// This custom deserialize logic therefore avoids calling [`Deserializer::deserialize_option`]\n/// alltogether. Instead, we'll try to deserialize the value as if it was present, and return\n/// [`None`] if the deserializer returns an error before calling the visitor. This is likely\n/// indicative of a type error, that would indicate a missing value.\n///\n/// ### Drawbacks\n///\n/// Using this deserialize logic might hide errors in the input. If this optional value\n/// is the last value that gets deserialized, and the deserialization failed due to some\n/// error other than a type error, it might get hidden.\n///\n/// Also, if trying to deserialize the value alters the state of the deserializer, it could\n/// lead to incorrect deserialization.\npub fn deserialize_option<'de, D, T>(deserializer: D) -> Result<Option<T>, D::Error>\nwhere\n\tD: Deserializer<'de>,\n\tT: Deserialize<'de>\n{\n\t// this flag will be set if any visitor method was called\n\tlet mut flag = false;\n\n\t// try to deserialize a present value\n\tlet result = T::deserialize(OptionDeserializer {\n\t\tde: deserializer,\n\t\tflag: &mut flag\n\t});\n\n\t// if the flag is not set and we don't have a value, assume a non-present value\n\tmatch result {\n\t\tOk(value) => Ok(Some(value)),\n\t\tErr(_) if !flag => Ok(None),\n\t\tErr(err) => Err(err)\n\t}\n}\n\n/// A deserializer that intercepts the visitor with our custom visitor.\nstruct OptionDeserializer<'a, D> {\n\tde: D,\n\tflag: &'a mut bool\n}\n\nmacro_rules! forward_deserializer {\n\t($(fn $ident:ident <$visitor:ident>(\n\t\tself,\n\t\t$visitor_arg:ident : $visitor_arg_ty:ty\n\t\t$(, $arg:ident : $arg_ty:ty)*\n\t);)+) => {\n\t\t$(\n\t\t\tfn $ident<$visitor>(\n\t\t\t\tself,\n\t\t\t\t$($arg: $arg_ty,)*\n\t\t\t\t$visitor_arg: $visitor_arg_ty\n\t\t\t) -> Result<$visitor::Value, Self::Error>\n\t\t\twhere\n\t\t\t\t$visitor: Visitor<'de>\n\t\t\t{\n\t\t\t\tlet $visitor_arg = OptionVisitor {\n\t\t\t\t\tvisitor: $visitor_arg,\n\t\t\t\t\tflag: self.flag\n\t\t\t\t};\n\t\t\t\tself.de.$ident($($arg,)* $visitor_arg)\n\t\t\t}\n\t\t)+\n\t};\n}\n\nimpl<'a, 'de, D> Deserializer<'de> for OptionDeserializer<'a, D>\nwhere\n\tD: Deserializer<'de>\n{\n\ttype Error = D::Error;\n\n\tforward_deserializer! {\n\t\tfn deserialize_any<V>(self, visitor: V);\n\t\tfn deserialize_bool<V>(self, visitor: V);\n\t\tfn deserialize_i8<V>(self, visitor: V);\n\t\tfn deserialize_i16<V>(self, visitor: V);\n\t\tfn deserialize_i32<V>(self, visitor: V);\n\t\tfn deserialize_i64<V>(self, visitor: V);\n\t\tfn deserialize_i128<V>(self, visitor: V);\n\t\tfn deserialize_u8<V>(self, visitor: V);\n\t\tfn deserialize_u16<V>(self, visitor: V);\n\t\tfn deserialize_u32<V>(self, visitor: V);\n\t\tfn deserialize_u64<V>(self, visitor: V);\n\t\tfn deserialize_u128<V>(self, visitor: V);\n\t\tfn deserialize_f32<V>(self, visitor: V);\n\t\tfn deserialize_f64<V>(self, visitor: V);\n\t\tfn deserialize_char<V>(self, visitor: V);\n\t\tfn deserialize_str<V>(self, visitor: V);\n\t\tfn deserialize_string<V>(self, visitor: V);\n\t\tfn deserialize_bytes<V>(self, visitor: V);\n\t\tfn deserialize_byte_buf<V>(self, visitor: V);\n\t\tfn deserialize_option<V>(self, visitor: V);\n\t\tfn deserialize_unit<V>(self, visitor: V);\n\t\tfn deserialize_unit_struct<V>(self, visitor: V, name: &'static str);\n\t\tfn deserialize_newtype_struct<V>(self, visitor: V, name: &'static str);\n\t\tfn deserialize_seq<V>(self, visitor: V);\n\t\tfn deserialize_tuple<V>(self, visitor: V, len: usize);\n\t\tfn deserialize_tuple_struct<V>(self, visitor: V, name: &'static str, len: usize);\n\t\tfn deserialize_map<V>(self, visitor: V);\n\t\tfn deserialize_struct<V>(self, visitor: V, name: &'static str, fields: &'static [&'static str]);\n\t\tfn deserialize_enum<V>(self, visitor: V, name: &'static str, variants: &'static [&'static str]);\n\t\tfn deserialize_identifier<V>(self, visitor: V);\n\t\tfn deserialize_ignored_any<V>(self, visitor: V);\n\t}\n\n\tfn is_human_readable(&self) -> bool {\n\t\tself.de.is_human_readable()\n\t}\n}\n\n/// A visitor that will set a flag if any visit method was called (except for visit_none).\n/// This indicates that the value was indeed present, i.e. any error return was not a\n/// general type error but instead a problem deserializing the correct type.\nstruct OptionVisitor<'a, V> {\n\tvisitor: V,\n\tflag: &'a mut bool\n}\n\nmacro_rules! forward_visitor {\n\t($(fn $ident:ident <$error:ident>(self $(, $arg:ident : $arg_ty:ty)*);)+) => {\n\t\t$(\n\t\t\tfn $ident<$error>(self $(, $arg: $arg_ty,)*) -> Result<Self::Value, $error>\n\t\t\twhere\n\t\t\t\t$error: de::Error\n\t\t\t{\n\t\t\t\t*self.flag = true;\n\t\t\t\tself.visitor.$ident($($arg),*)\n\t\t\t}\n\t\t)+\n\t};\n\n\t($(fn $ident:ident <$access:ident : $access_bound:path>(\n\t\tself $(, $arg:ident : $arg_ty:ty)*\n\t);)+) => {\n\t\t$(\n\t\t\tfn $ident<$access>(self $(, $arg: $arg_ty,)*) -> Result<Self::Value, $access::Error>\n\t\t\twhere\n\t\t\t\t$access: $access_bound\n\t\t\t{\n\t\t\t\t*self.flag = true;\n\t\t\t\tself.visitor.$ident($($arg),*)\n\t\t\t}\n\t\t)+\n\t};\n}\n\nimpl<'a, 'de, V> Visitor<'de> for OptionVisitor<'a, V>\nwhere\n\tV: Visitor<'de>\n{\n\ttype Value = V::Value;\n\n\tfn expecting(&self, f: &mut Formatter<'_>) -> fmt::Result {\n\t\tf.write_str(\"optional \")?;\n\t\tself.visitor.expecting(f)\n\t}\n\n\tforward_visitor! {\n\t\tfn visit_bool<E>(self, v: bool);\n\t\tfn visit_i8<E>(self, v: i8);\n\t\tfn visit_i16<E>(self, v: i16);\n\t\tfn visit_i32<E>(self, v: i32);\n\t\tfn visit_i64<E>(self, v: i64);\n\t\tfn visit_i128<E>(self, v: i128);\n\t\tfn visit_u8<E>(self, v: u8);\n\t\tfn visit_u16<E>(self, v: u16);\n\t\tfn visit_u32<E>(self, v: u32);\n\t\tfn visit_u64<E>(self, v: u64);\n\t\tfn visit_u128<E>(self, v: u128);\n\t\tfn visit_f32<E>(self, v: f32);\n\t\tfn visit_f64<E>(self, v: f64);\n\t\tfn visit_char<E>(self, v: char);\n\t\tfn visit_str<E>(self, v: &str);\n\t\tfn visit_borrowed_str<E>(self, v: &'de str);\n\t\tfn visit_string<E>(self, v: String);\n\t\tfn visit_bytes<E>(self, v: &[u8]);\n\t\tfn visit_borrowed_bytes<E>(self, v: &'de [u8]);\n\t\tfn visit_byte_buf<E>(self, v: Vec<u8>);\n\t\tfn visit_unit<E>(self);\n\t}\n\n\tfn visit_none<E>(self) -> Result<Self::Value, E>\n\twhere\n\t\tE: de::Error\n\t{\n\t\t// special case - if we don't set the flag and return an error, we'll\n\t\t// get None\n\t\tErr(E::custom(\"\"))\n\t}\n\n\tforward_visitor! {\n\t\tfn visit_some<D: Deserializer<'de>>(self, de: D);\n\t\tfn visit_newtype_struct<D: Deserializer<'de>>(self, de: D);\n\t\tfn visit_seq<A: SeqAccess<'de>>(self, seq: A);\n\t\tfn visit_map<A: MapAccess<'de>>(self, map: A);\n\t\tfn visit_enum<A: EnumAccess<'de>>(self, data: A);\n\t}\n}\n","traces":[{"line":53,"address":[430576,430800,430736,430864,430640,430928,430896,430768,430704],"length":1,"stats":{"Line":5},"fn_name":"deserialize<f32, serde_sexpr::de::Field>"},{"line":57,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":65,"address":[431088,430960,431024],"length":1,"stats":{"Line":6},"fn_name":"serialize<f32, serde_sexpr::ser::Field>"},{"line":69,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":128,"address":[433776,431632,432448,431152,434768,432848,432048,433360,434288],"length":1,"stats":{"Line":5},"fn_name":"deserialize_option<serde_sexpr::de::TrueField, test::Drill>"},{"line":134,"address":[431648,433376,431168,434304,432865,433793,432464,432064,434785],"length":1,"stats":{"Line":5},"fn_name":null},{"line":137,"address":[431661,432077,433389,431181,434824,434317,432477,432904,433832],"length":1,"stats":{"Line":5},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[436480,436608,436176,436224,436352,436736,436304,436128,436432],"length":1,"stats":{"Line":5},"fn_name":"deserialize_f32<serde_sexpr::de::MissingField, serde::de::impls::{impl#52}::deserialize::PrimitiveVisitor>"},{"line":171,"address":[436193,436569,436449,436240,436145,436772,436321,436368,436697],"length":1,"stats":{"Line":5},"fn_name":null},{"line":173,"address":[436768,436364,436236],"length":1,"stats":{"Line":3},"fn_name":null},{"line":175,"address":[436777,436326,436150,436373,436245,436198,436454,436702,436574],"length":1,"stats":{"Line":5},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[435472,435408,435344,435952,436000],"length":1,"stats":{"Line":2},"fn_name":"visit_bool<serde::de::impls::{impl#43}::deserialize::PrimitiveVisitor, serde_sexpr::de::error::Error>"},{"line":241,"address":[435435,435371,436024,435974,435499],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[435374,435977,436027,435438,435502],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[436048],"length":1,"stats":{"Line":1},"fn_name":"visit_map<test::_::{impl#0}::deserialize::__Visitor, serde_sexpr::de::SExpr>"},{"line":255,"address":[436080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[436083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[435915,435771,435808,435642,435536,435664],"length":1,"stats":{"Line":2},"fn_name":"visit_none<serde::de::impls::{impl#43}::deserialize::PrimitiveVisitor, serde_sexpr::de::error::Error>"},{"line":303,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":23,"coverable":30},{"path":["/","home","runner","work","serde_sexpr","serde_sexpr","src","ser","error.rs"],"content":"use serde::ser;\nuse std::fmt::Display;\nuse thiserror::Error;\n\n#[derive(Clone, Debug, Error, PartialEq)]\npub enum Error {\n\t#[error(\"{0}\")]\n\tMessage(String),\n\n\t/// This error will be returned if you request to serialize anything but a struct at root\n\t/// level.\n\t#[error(\"Expected to serialize a struct at root level\")]\n\tExpectedStruct,\n\n\t/// This error will be returned if a boolean was detected in an unnamed container, i.e.\n\t/// a tuple or a sequence.\n\t#[error(\"Unnamed boolean\")]\n\tUnnamedBoolean,\n\n\t/// This error will be returned if a sequence was detected in an unnamed container, i.e. a\n\t/// tuple or a sequence.\n\t#[error(\"Unnamed sequence\")]\n\tUnnamedSeq,\n\n\t#[error(\"char is unsupported\")]\n\tChar,\n\t#[error(\"byte array is unsupported\")]\n\tBytes,\n\t#[error(\"unit is unsupported\")]\n\tUnit,\n\t#[error(\"enums with non-unit variants are not supported\")]\n\tComplexEnum,\n\t#[error(\"maps are not supported\")]\n\tMap\n}\n\nimpl ser::Error for Error {\n\tfn custom<T: Display>(msg: T) -> Self {\n\t\tSelf::Message(msg.to_string())\n\t}\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","runner","work","serde_sexpr","serde_sexpr","src","ser","mod.rs"],"content":"use itoa::Integer;\nuse paste::paste;\nuse serde::ser::{\n\tself, Serialize, SerializeSeq, SerializeStruct, SerializeTuple, SerializeTupleStruct\n};\n\nmod error;\npub use error::Error;\n\npub struct Serializer {\n\t/// Buffer that the output gets written to.\n\tbuf: String,\n\n\t/// Set to true for pretty output.\n\tpretty: bool,\n\n\t/// The current level of nesting\n\tlvl: usize,\n\n\t/// The indentation (in levels) of the current line\n\tindent: usize,\n\n\t/// An itoa::Buffer to re-use when printing integers\n\titoa_buffer: itoa::Buffer\n}\n\nimpl Serializer {\n\tfn new(pretty: bool) -> Self {\n\t\tSelf {\n\t\t\tbuf: String::new(),\n\t\t\tpretty,\n\t\t\tlvl: 0,\n\t\t\tindent: 0,\n\t\t\titoa_buffer: itoa::Buffer::new()\n\t\t}\n\t}\n}\n\ntype Result<T, E = Error> = std::result::Result<T, E>;\n\npub fn to_string<T>(value: &T) -> Result<String>\nwhere\n\tT: ?Sized + Serialize\n{\n\tlet mut serializer = Serializer::new(false);\n\tvalue.serialize(&mut serializer)?;\n\tOk(serializer.buf)\n}\n\npub fn to_string_pretty<T>(value: &T) -> Result<String>\nwhere\n\tT: ?Sized + Serialize\n{\n\tlet mut serializer = Serializer::new(true);\n\tvalue.serialize(&mut serializer)?;\n\tOk(serializer.buf)\n}\n\nimpl Serializer {\n\tfn newline(&mut self) {\n\t\tself.buf += \"\\n\";\n\t\tfor _ in 0..self.lvl {\n\t\t\tself.buf += \"  \";\n\t\t}\n\t\tself.indent = self.lvl;\n\t}\n\n\tfn begin_sexpr(&mut self, name: &str) {\n\t\tif self.lvl > 0 {\n\t\t\tif self.pretty {\n\t\t\t\tself.newline();\n\t\t\t} else {\n\t\t\t\tself.buf += \" \";\n\t\t\t}\n\t\t}\n\t\tself.lvl += 1;\n\t\tself.buf += \"(\";\n\t\tself.buf += name;\n\t}\n\n\tfn end_sexpr(&mut self) {\n\t\tself.lvl -= 1;\n\t\tself.buf += \")\";\n\t}\n\n\tfn write_integer<I: Integer>(&mut self, v: I) {\n\t\tself.buf += \" \";\n\t\tself.buf += self.itoa_buffer.format(v);\n\t}\n\n\tfn write_float<F: ToString>(&mut self, v: F) {\n\t\tself.buf += \" \";\n\t\tself.buf += &v.to_string();\n\t}\n\n\tfn write_str(&mut self, v: &str) {\n\t\tself.buf += \" \";\n\n\t\tconst CHARS: &[char] = &[' ', '\\t', '\\n', '\\r', '(', ')', '\"'];\n\t\tlet need_quotes =\n\t\t\tv.is_empty() || v.contains(CHARS) || v.chars().next().unwrap().is_ascii_digit();\n\n\t\tif need_quotes {\n\t\t\tself.buf += r#\"\"\"#;\n\t\t\tself.buf += &v.replace('\\\\', r\"\\\\\").replace('\"', r#\"\\\"\"#);\n\t\t\tself.buf += r#\"\"\"#;\n\t\t} else {\n\t\t\tself.buf += v;\n\t\t}\n\t}\n}\n\nmacro_rules! serialize_type_error {\n\t($(fn $ident:ident $(<$T:ident>)? (self $(, $arg_ty:ty)*);)+) => {\n\t\t$(\n\t\t\tfn $ident $(<$T>)? (self $(, _: $arg_ty)*) -> Result<Self::Ok, Self::Error>\n\t\t\t$(where $T: ?Sized + Serialize)?\n\t\t\t{\n\t\t\t\tErr(Error::ExpectedStruct)\n\t\t\t}\n\t\t)+\n\t};\n\n\t($(fn $ident:ident $(<$T:ident>)? (self $(, $arg_ty:ty)*) -> $ret:ty;)+) => {\n\t\t$(\n\t\t\tfn $ident $(<$T>)? (self $(, _: $arg_ty)*) -> $ret\n\t\t\t$(where $T: ?Sized + Serialize)?\n\t\t\t{\n\t\t\t\tErr(Error::ExpectedStruct)\n\t\t\t}\n\t\t)+\n\t};\n\n\t($(fn $ident:ident $(<$T:ident>)? (self $(, $arg_ty:ty)*) = $err:expr;)+) => {\n\t\t$(\n\t\t\tfn $ident $(<$T>)? (self $(, _: $arg_ty)*) -> Result<Self::Ok, Self::Error>\n\t\t\t$(where $T: ?Sized + Serialize)?\n\t\t\t{\n\t\t\t\tErr($err)\n\t\t\t}\n\t\t)+\n\t};\n\n\t($(fn $ident:ident $(<$T:ident>)? (self $(, $arg_ty:ty)*) -> $ret:ty = $err:expr;)+) => {\n\t\t$(\n\t\t\tfn $ident $(<$T>)? (self $(, _: $arg_ty)*) -> $ret\n\t\t\t$(where $T: ?Sized + Serialize)?\n\t\t\t{\n\t\t\t\tErr($err)\n\t\t\t}\n\t\t)+\n\t};\n}\n\ntype Impossible<T = (), E = Error> = serde::ser::Impossible<T, E>;\n\nimpl<'a> ser::Serializer for &'a mut Serializer {\n\ttype Ok = ();\n\ttype Error = Error;\n\n\ttype SerializeSeq = Impossible;\n\ttype SerializeTuple = Impossible;\n\ttype SerializeTupleStruct = Self;\n\ttype SerializeTupleVariant = Impossible;\n\ttype SerializeMap = Impossible;\n\ttype SerializeStruct = Self;\n\ttype SerializeStructVariant = Impossible;\n\n\tserialize_type_error! {\n\t\tfn serialize_bool(self, bool);\n\t\tfn serialize_i8(self, i8);\n\t\tfn serialize_i16(self, i16);\n\t\tfn serialize_i32(self, i32);\n\t\tfn serialize_i64(self, i64);\n\t\tfn serialize_i128(self, i128);\n\t\tfn serialize_u8(self, u8);\n\t\tfn serialize_u16(self, u16);\n\t\tfn serialize_u32(self, u32);\n\t\tfn serialize_u64(self, u64);\n\t\tfn serialize_u128(self, u128);\n\t\tfn serialize_f32(self, f32);\n\t\tfn serialize_f64(self, f64);\n\t\tfn serialize_char(self, char);\n\t\tfn serialize_str(self, &str);\n\t\tfn serialize_bytes(self, &[u8]);\n\t\tfn serialize_none(self);\n\t\tfn serialize_some<T>(self, &T);\n\t\tfn serialize_unit(self);\n\t\tfn serialize_unit_variant(self, &'static str, u32, &'static str);\n\t\tfn serialize_newtype_variant<T>(self, &'static str, u32, &'static str, &T);\n\t}\n\n\tserialize_type_error! {\n\t\tfn serialize_seq(self, Option<usize>) -> Result<Impossible>;\n\t\tfn serialize_tuple(self, usize) -> Result<Impossible>;\n\t\tfn serialize_tuple_variant(self, &'static str, u32, &'static str, usize) -> Result<Impossible>;\n\t\tfn serialize_map(self, Option<usize>) -> Result<Impossible>;\n\t\tfn serialize_struct_variant(self, &'static str, u32, &'static str, usize) -> Result<Impossible>;\n\t}\n\n\tfn serialize_unit_struct(self, name: &'static str) -> Result<()> {\n\t\tself.begin_sexpr(name);\n\t\tself.end_sexpr();\n\t\tOk(())\n\t}\n\n\tfn serialize_newtype_struct<T>(self, name: &'static str, value: &T) -> Result<()>\n\twhere\n\t\tT: ?Sized + Serialize\n\t{\n\t\tself.begin_sexpr(name);\n\t\tvalue.serialize(Field {\n\t\t\tser: &mut *self,\n\t\t\tname: None\n\t\t})?;\n\t\tself.end_sexpr();\n\t\tOk(())\n\t}\n\n\tfn serialize_tuple_struct(self, name: &'static str, _len: usize) -> Result<Self> {\n\t\tself.begin_sexpr(name);\n\t\tOk(self)\n\t}\n\n\tfn serialize_struct(self, name: &'static str, _len: usize) -> Result<Self> {\n\t\tself.begin_sexpr(name);\n\t\tOk(self)\n\t}\n}\n\nimpl<'a> SerializeTupleStruct for &'a mut Serializer {\n\ttype Ok = ();\n\ttype Error = Error;\n\n\tfn serialize_field<T>(&mut self, value: &T) -> Result<()>\n\twhere\n\t\tT: ?Sized + Serialize\n\t{\n\t\tvalue.serialize(Field {\n\t\t\tser: &mut **self,\n\t\t\tname: None\n\t\t})\n\t}\n\n\tfn end(self) -> Result<()> {\n\t\tself.end_sexpr();\n\t\tOk(())\n\t}\n}\n\nimpl<'a> SerializeStruct for &'a mut Serializer {\n\ttype Ok = ();\n\ttype Error = Error;\n\n\tfn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n\twhere\n\t\tT: ?Sized + Serialize\n\t{\n\t\t// TODO this should probably not be self\n\t\tvalue.serialize(Field {\n\t\t\tser: &mut **self,\n\t\t\tname: Some(key)\n\t\t})\n\t}\n\n\tfn end(self) -> Result<()> {\n\t\tself.end_sexpr();\n\t\tOk(())\n\t}\n}\n\n/// This serializer will serialize all fields. It needs the field name for booleans and\n/// sequences.\nstruct Field<'a> {\n\tser: &'a mut Serializer,\n\tname: Option<&'static str>\n}\n\nmacro_rules! serialize_integer {\n\t($($integer:ty)+) => {\n\t\t$(\n\t\t\tpaste! {\n\t\t\t\tfn [<serialize_ $integer>](self, v: $integer) -> Result<()> {\n\t\t\t\t\tself.ser.write_integer(v);\n\t\t\t\t\tOk(())\n\t\t\t\t}\n\t\t\t}\n\t\t)+\n\t};\n}\n\nimpl<'a> ser::Serializer for Field<'a> {\n\ttype Ok = ();\n\ttype Error = Error;\n\n\ttype SerializeSeq = Self;\n\ttype SerializeTuple = Self;\n\ttype SerializeTupleStruct = &'a mut Serializer;\n\ttype SerializeTupleVariant = Impossible;\n\ttype SerializeMap = Impossible;\n\ttype SerializeStruct = &'a mut Serializer;\n\ttype SerializeStructVariant = Impossible;\n\n\tserialize_type_error! {\n\t\tfn serialize_char(self, char) = Error::Char;\n\t\tfn serialize_bytes(self, &[u8]) = Error::Bytes;\n\t\tfn serialize_unit(self) = Error::Unit;\n\t\tfn serialize_newtype_variant<T>(self, &'static str, u32, &'static str, &T) = Error::ComplexEnum;\n\t}\n\n\tserialize_type_error! {\n\t\tfn serialize_tuple_variant(self, &'static str, u32, &'static str, usize) -> Result<Impossible> = Error::ComplexEnum;\n\t\tfn serialize_map(self, Option<usize>) -> Result<Impossible> = Error::Map;\n\t\tfn serialize_struct_variant(self, &'static str, u32, &'static str, usize) -> Result<Impossible> = Error::ComplexEnum;\n\t}\n\n\tfn serialize_bool(self, v: bool) -> Result<()> {\n\t\tlet name = self.name.ok_or(Error::UnnamedBoolean)?;\n\t\tif v {\n\t\t\tself.serialize_str(name)?;\n\t\t}\n\t\tOk(())\n\t}\n\n\tserialize_integer! {\n\t\ti8 i16 i32 i64 i128 u8 u16 u32 u64 u128\n\t}\n\n\tfn serialize_f32(self, v: f32) -> Result<()> {\n\t\tself.ser.write_float(v);\n\t\tOk(())\n\t}\n\n\tfn serialize_f64(self, v: f64) -> Result<()> {\n\t\tself.ser.write_float(v);\n\t\tOk(())\n\t}\n\n\tfn serialize_str(self, v: &str) -> Result<()> {\n\t\tself.ser.write_str(v);\n\t\tOk(())\n\t}\n\n\tfn serialize_none(self) -> Result<()> {\n\t\tOk(())\n\t}\n\n\tfn serialize_some<T>(self, v: &T) -> Result<()>\n\twhere\n\t\tT: ?Sized + Serialize\n\t{\n\t\tv.serialize(self)\n\t}\n\n\tfn serialize_unit_struct(self, name: &'static str) -> Result<()> {\n\t\tself.ser.serialize_unit_struct(name)\n\t}\n\n\tfn serialize_unit_variant(\n\t\tself,\n\t\t_name: &'static str,\n\t\t_variant_index: u32,\n\t\tvariant: &'static str\n\t) -> Result<()> {\n\t\tself.ser.write_str(variant);\n\t\tOk(())\n\t}\n\n\tfn serialize_newtype_struct<T>(self, name: &'static str, value: &T) -> Result<()>\n\twhere\n\t\tT: ?Sized + Serialize\n\t{\n\t\tself.ser.serialize_newtype_struct(name, value)\n\t}\n\n\tfn serialize_seq(self, _len: Option<usize>) -> Result<Self> {\n\t\tlet name = self.name.ok_or(Error::UnnamedSeq)?;\n\t\tself.ser.begin_sexpr(name);\n\t\tOk(self)\n\t}\n\n\tfn serialize_tuple(self, _len: usize) -> Result<Self> {\n\t\tlet name = self.name.ok_or(Error::UnnamedSeq)?;\n\t\tself.ser.begin_sexpr(name);\n\t\tOk(self)\n\t}\n\n\tfn serialize_tuple_struct(self, name: &'static str, len: usize) -> Result<&'a mut Serializer> {\n\t\tself.ser.serialize_tuple_struct(name, len)\n\t}\n\n\tfn serialize_struct(self, name: &'static str, len: usize) -> Result<&'a mut Serializer> {\n\t\tself.ser.serialize_struct(name, len)\n\t}\n}\n\nimpl<'a> SerializeSeq for Field<'a> {\n\ttype Ok = ();\n\ttype Error = Error;\n\n\tfn serialize_element<T>(&mut self, value: &T) -> Result<()>\n\twhere\n\t\tT: ?Sized + Serialize\n\t{\n\t\tvalue.serialize(Field {\n\t\t\tser: &mut *self.ser,\n\t\t\tname: None\n\t\t})\n\t}\n\n\tfn end(self) -> Result<()> {\n\t\tself.ser.end_sexpr();\n\t\tOk(())\n\t}\n}\n\nimpl<'a> SerializeTuple for Field<'a> {\n\ttype Ok = ();\n\ttype Error = Error;\n\n\tfn serialize_element<T>(&mut self, value: &T) -> Result<()>\n\twhere\n\t\tT: ?Sized + Serialize\n\t{\n\t\tvalue.serialize(Field {\n\t\t\tser: &mut *self.ser,\n\t\t\tname: None\n\t\t})\n\t}\n\n\tfn end(self) -> Result<()> {\n\t\tself.ser.end_sexpr();\n\t\tOk(())\n\t}\n}\n","traces":[{"line":28,"address":[212048,212211],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":30,"address":[212075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[212090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[284048,283212,284812,282848,284012,283612,284412,283248,285212,284848,284448,283648],"length":1,"stats":{"Line":7},"fn_name":"to_string<test::Size>"},{"line":45,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":50,"address":[280815,280848,281615,282048,282415,281248,281215,282815,280448,282015,282448,281648],"length":1,"stats":{"Line":7},"fn_name":"to_string_pretty<test::Locked>"},{"line":54,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":60,"address":[212224],"length":1,"stats":{"Line":2},"fn_name":"newline"},{"line":61,"address":[212238],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[212260,212382],"length":1,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[212397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[212364],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[212416],"length":1,"stats":{"Line":1},"fn_name":"begin_sexpr"},{"line":69,"address":[212450],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[212488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[212523],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[212499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[212462,212562,212539],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[212543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[212607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[212624],"length":1,"stats":{"Line":1},"fn_name":"end_sexpr"},{"line":82,"address":[212637,212689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[212670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[232240,232128,231904,232016,232480,232592,231792,232368,231680,231568],"length":1,"stats":{"Line":3},"fn_name":"write_integer<u32>"},{"line":87,"address":[231590,232393,231817,231702,232040,232626,232274,232152,232507,231931],"length":1,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[231616,232306,232658,232179,231728,232419,231843,231958,232067,232534],"length":1,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[233085,232912,232720,232893],"length":1,"stats":{"Line":2},"fn_name":"write_float<f32>"},{"line":92,"address":[232740,232932],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[232971,233001,232809,232779],"length":1,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[213305,212736],"length":1,"stats":{"Line":1},"fn_name":"write_str"},{"line":97,"address":[212782],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[212809,212930],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[212921],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[213020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[213057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[213325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[213005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[215888,216416,215808,216048,216256,216336,216624,216112,216784,217136,215968,216480,216544,216176,216928,216848,217072,217008,216704],"length":1,"stats":{"Line":0},"fn_name":"serialize_bool"},{"line":119,"address":[216950,217084,215906,217202,216064,216497,216722,216198,216800,217020,216642,216129,216274,215988,216566,216432,215829,216356,216870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[217616,217536,217344,217264,217408],"length":1,"stats":{"Line":0},"fn_name":"serialize_seq"},{"line":129,"address":[217361,217479,217286,217558,217687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[217808,217872,217744],"length":1,"stats":{"Line":0},"fn_name":"serialize_char"},{"line":139,"address":[217833,217887,217763],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[218048,218112,217936],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple_variant"},{"line":149,"address":[217998,218174,218073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[213360],"length":1,"stats":{"Line":1},"fn_name":"serialize_unit_struct"},{"line":202,"address":[213428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[213438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[213453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[286688],"length":1,"stats":{"Line":1},"fn_name":"serialize_newtype_struct<alloc::string::String>"},{"line":211,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[213472],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple_struct"},{"line":221,"address":[213543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[213563],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[213584],"length":1,"stats":{"Line":2},"fn_name":"serialize_struct"},{"line":226,"address":[213655],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[213675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[213696],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":246,"address":[213728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[213743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[287536,287648,287872,287984,288096,287200,287088,288208,287760,287312,287424],"length":1,"stats":{"Line":20},"fn_name":"serialize_field<test::_::{impl#0}::serialize::__SerializeWith>"},{"line":260,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":266,"address":[213760],"length":1,"stats":{"Line":2},"fn_name":"end"},{"line":267,"address":[213792],"length":1,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[213807],"length":1,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[218352,218688,218416,218816,218480,218288,218752,218624,218224,218560],"length":1,"stats":{"Line":3},"fn_name":"serialize_i8"},{"line":284,"address":[218243,218309,218448,218866,218579,218381,218784,218645,218530,218717],"length":1,"stats":{"Line":3},"fn_name":null},{"line":285,"address":[218599,218802,218329,218399,218665,218884,218263,218466,218548,218735],"length":1,"stats":{"Line":3},"fn_name":null},{"line":305,"address":[217755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[217825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[217879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[217989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[218065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[218165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[213824],"length":1,"stats":{"Line":2},"fn_name":"serialize_bool"},{"line":318,"address":[213865,214007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":319,"address":[214282,213989],"length":1,"stats":{"Line":3},"fn_name":null},{"line":320,"address":[214179,214292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[214156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[214448],"length":1,"stats":{"Line":2},"fn_name":"serialize_f32"},{"line":330,"address":[214467],"length":1,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[214484],"length":1,"stats":{"Line":2},"fn_name":null},{"line":334,"address":[214496],"length":1,"stats":{"Line":0},"fn_name":"serialize_f64"},{"line":335,"address":[214515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[214532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[214544],"length":1,"stats":{"Line":1},"fn_name":"serialize_str"},{"line":340,"address":[214594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[214612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[214624],"length":1,"stats":{"Line":2},"fn_name":"serialize_none"},{"line":345,"address":[214627],"length":1,"stats":{"Line":2},"fn_name":null},{"line":348,"address":[286512,286352,286432],"length":1,"stats":{"Line":4},"fn_name":"serialize_some<i16>"},{"line":352,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":355,"address":[214640],"length":1,"stats":{"Line":0},"fn_name":"serialize_unit_struct"},{"line":356,"address":[214661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[214688],"length":1,"stats":{"Line":2},"fn_name":"serialize_unit_variant"},{"line":365,"address":[214756],"length":1,"stats":{"Line":2},"fn_name":null},{"line":366,"address":[214774],"length":1,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[214800],"length":1,"stats":{"Line":2},"fn_name":"serialize_seq"},{"line":377,"address":[214969,214841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[214951],"length":1,"stats":{"Line":2},"fn_name":null},{"line":379,"address":[215123],"length":1,"stats":{"Line":2},"fn_name":null},{"line":382,"address":[215216],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple"},{"line":383,"address":[215248,215375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[215357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[215528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[215616],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple_struct"},{"line":389,"address":[215643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[215664],"length":1,"stats":{"Line":2},"fn_name":"serialize_struct"},{"line":393,"address":[215691],"length":1,"stats":{"Line":2},"fn_name":null},{"line":401,"address":[286592],"length":1,"stats":{"Line":2},"fn_name":"serialize_element<&alloc::string::String>"},{"line":405,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":411,"address":[215712],"length":1,"stats":{"Line":2},"fn_name":"end"},{"line":412,"address":[215726],"length":1,"stats":{"Line":2},"fn_name":null},{"line":413,"address":[215744],"length":1,"stats":{"Line":2},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[215760],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":432,"address":[215774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[215792],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":95,"coverable":137},{"path":["/","home","runner","work","serde_sexpr","serde_sexpr","tests","test.rs"],"content":"use indoc::indoc;\nuse paste::paste;\nuse pretty_assertions::assert_eq;\nuse serde::{de::DeserializeOwned, Deserialize, Serialize};\nuse serde_sexpr::Literal;\nuse std::fmt::Debug;\n\nfn assert_eq_parsed<T>(input: &str, expected: &T)\nwhere\n\tT: Debug + DeserializeOwned + PartialEq\n{\n\tlet parsed: T = serde_sexpr::from_str(input).expect(\"Failed to parse input\");\n\tassert_eq!(&parsed, expected);\n}\n\nfn assert_eq_ugly<T>(input: &T, expected: &str)\nwhere\n\tT: ?Sized + Serialize\n{\n\tlet written = serde_sexpr::to_string(input).expect(\"Failed to write input\");\n\tassert_eq!(written.as_str(), expected);\n}\n\nfn assert_eq_pretty<T>(input: &T, expected: &str)\nwhere\n\tT: ?Sized + Serialize\n{\n\tlet written = serde_sexpr::to_string_pretty(input).expect(\"Failed to write input\");\n\tassert_eq!(written.as_str(), expected.trim_end_matches('\\n'));\n}\n\nmacro_rules! test_case {\n\t(name: $name:ident,input: $input:expr,pretty: $pretty:expr,value: $value:expr) => {\n\t\tpaste! {\n\t\t\tconst [<TEST_CASE_INPUT_ $name:upper>]: &str = $input;\n\t\t\tconst [<TEST_CASE_PRETTY_ $name:upper>]: &str = $pretty;\n\n\t\t\t#[test]\n\t\t\tfn [<test_deserialize_ugly_ $name>]() {\n\t\t\t\tlet value = $value;\n\t\t\t\tassert_eq_parsed([<TEST_CASE_INPUT_ $name:upper>], &value);\n\t\t\t}\n\n\t\t\t#[test]\n\t\t\tfn [<test_deserialize_pretty_ $name>]() {\n\t\t\t\tlet value = $value;\n\t\t\t\tassert_eq_parsed([<TEST_CASE_PRETTY_ $name:upper>], &value);\n\t\t\t}\n\n\t\t\t#[test]\n\t\t\tfn [<test_serialize_ugly_ $name>]() {\n\t\t\t\tlet value = $value;\n\t\t\t\tassert_eq_ugly(&value, [<TEST_CASE_INPUT_ $name:upper>]);\n\t\t\t}\n\n\t\t\t#[test]\n\t\t\tfn [<test_serialize_pretty_ $name>]() {\n\t\t\t\tlet value = $value;\n\t\t\t\tassert_eq_pretty(&value, [<TEST_CASE_PRETTY_ $name:upper>]);\n\t\t\t}\n\t\t}\n\t};\n}\n\n// ################################################################################################\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(rename = \"locked\")]\nstruct Locked;\n\ntest_case! {\n\tname: locked,\n\tinput: \"(locked)\",\n\tpretty: \"(locked)\",\n\tvalue: Locked\n}\n\n// ################################################################################################\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(rename = \"attr\")]\nstruct Attribute(String);\n\ntest_case! {\n\tname: attr,\n\tinput: \"(attr smd)\",\n\tpretty: \"(attr smd)\",\n\tvalue: Attribute(\"smd\".to_owned())\n}\n\n// ################################################################################################\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(rename = \"descr\")]\nstruct Description(String);\n\ntest_case! {\n\tname: descr,\n\tinput: r#\"(descr \"Hello \\\"World\\\", this \\\"\\\\\\\" is an amazing backspace! \\\\\")\"#,\n\tpretty: r#\"(descr \"Hello \\\"World\\\", this \\\"\\\\\\\" is an amazing backspace! \\\\\")\"#,\n\tvalue: Description(r#\"Hello \"World\", this \"\\\" is an amazing backspace! \\\"#.to_owned())\n}\n\n// ################################################################################################\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(rename = \"at\")]\nstruct Position {\n\tx: f32,\n\ty: f32,\n\t#[serde(with = \"serde_sexpr::Option\")]\n\trot: Option<i16>\n}\n\ntest_case! {\n\tname: position_without_rot,\n\tinput: \"(at 1.23 -4.56)\",\n\tpretty: \"(at 1.23 -4.56)\",\n\tvalue: Position {\n\t\tx: 1.23,\n\t\ty: -4.56,\n\t\trot: None\n\t}\n}\n\ntest_case! {\n\tname: position_with_rot,\n\tinput: \"(at 1.23 -4.56 -90)\",\n\tpretty: \"(at 1.23 -4.56 -90)\",\n\tvalue: Position {\n\t\tx: 1.23,\n\t\ty: -4.56,\n\t\trot: Some(-90)\n\t}\n}\n\n// ################################################################################################\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(rename = \"size\")]\nstruct Size {\n\twidth: f32,\n\theight: f32\n}\n\ntest_case! {\n\tname: size,\n\tinput: \"(size 1.23 4.56)\",\n\tpretty: \"(size 1.23 4.56)\",\n\tvalue: Size {\n\t\twidth: 1.23,\n\t\theight: 4.56\n\t}\n}\n\n// ################################################################################################\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\nenum PadType {\n\t#[serde(rename = \"thru-hole\")]\n\tThroughHole,\n\n\t#[serde(rename = \"smd\")]\n\tSmd\n}\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(rename_all = \"lowercase\")]\nenum PadShape {\n\tCircle,\n\tRect\n}\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(rename = \"drill\")]\nstruct Drill {\n\toval: bool,\n\tdrill1: f32,\n\t#[serde(with = \"serde_sexpr::Option\")]\n\tdrill2: Option<f32>\n}\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(rename = \"pad\")]\nstruct Pad {\n\tindex: Literal,\n\tty: PadType,\n\tshape: PadShape,\n\tat: Position,\n\tsize: Size,\n\t#[serde(with = \"serde_sexpr::Option\")]\n\tdrill: Option<Drill>,\n\tlayers: Vec<String>\n}\n\ntest_case! {\n\tname: pad_without_drill,\n\tinput: \"(pad 1 smd rect (at 0 0) (size 1.27 1.27) (layers F.Cu))\",\n\tpretty: indoc!(r#\"\n\t\t(pad 1 smd rect\n\t\t  (at 0 0)\n\t\t  (size 1.27 1.27)\n\t\t  (layers F.Cu))\n\t\"#),\n\tvalue: Pad {\n\t\tindex: 1.into(),\n\t\tty: PadType::Smd,\n\t\tshape: PadShape::Rect,\n\t\tat: Position {\n\t\t\tx: 0.0,\n\t\t\ty: 0.0,\n\t\t\trot: None\n\t\t},\n\t\tsize: Size {\n\t\t\twidth: 1.27,\n\t\t\theight: 1.27\n\t\t},\n\t\tdrill: None,\n\t\tlayers: vec![\"F.Cu\".to_owned()]\n\t}\n}\n\ntest_case! {\n\tname: pad_with_drill,\n\tinput: \"(pad 1 thru-hole rect (at 0 0) (size 1.27 1.27) (drill 0.635) (layers F.Cu))\",\n\tpretty: indoc!(r#\"\n\t\t(pad 1 thru-hole rect\n\t\t  (at 0 0)\n\t\t  (size 1.27 1.27)\n\t\t  (drill 0.635)\n\t\t  (layers F.Cu))\n\t\"#),\n\tvalue: Pad {\n\t\tindex: 1.into(),\n\t\tty: PadType::ThroughHole,\n\t\tshape: PadShape::Rect,\n\t\tat: Position {\n\t\t\tx: 0.0,\n\t\t\ty: 0.0,\n\t\t\trot: None\n\t\t},\n\t\tsize: Size {\n\t\t\twidth: 1.27,\n\t\t\theight: 1.27\n\t\t},\n\t\tdrill: Some(Drill {\n\t\t\toval: false,\n\t\t\tdrill1: 0.635,\n\t\t\tdrill2: None\n\t\t}),\n\t\tlayers: vec![\"F.Cu\".to_owned()]\n\t}\n}\n\ntest_case! {\n\tname: pad_with_oval_drill,\n\tinput: \"(pad 1 thru-hole rect (at 0 0) (size 1.27 1.27) (drill oval 0.635 0.847) (layers F.Cu))\",\n\tpretty: indoc!(r#\"\n\t\t(pad 1 thru-hole rect\n\t\t  (at 0 0)\n\t\t  (size 1.27 1.27)\n\t\t  (drill oval 0.635 0.847)\n\t\t  (layers F.Cu))\n\t\"#),\n\tvalue: Pad {\n\t\tindex: 1.into(),\n\t\tty: PadType::ThroughHole,\n\t\tshape: PadShape::Rect,\n\t\tat: Position {\n\t\t\tx: 0.0,\n\t\t\ty: 0.0,\n\t\t\trot: None\n\t\t},\n\t\tsize: Size {\n\t\t\twidth: 1.27,\n\t\t\theight: 1.27\n\t\t},\n\t\tdrill: Some(Drill {\n\t\t\toval: true,\n\t\t\tdrill1: 0.635,\n\t\t\tdrill2: Some(0.847)\n\t\t}),\n\t\tlayers: vec![\"F.Cu\".to_owned()]\n\t}\n}\n","traces":[],"covered":0,"coverable":0}]}