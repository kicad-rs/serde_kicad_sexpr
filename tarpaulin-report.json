{"files":[{"path":["/","home","runner","work","serde_kicad_sexpr","serde_kicad_sexpr","src","de","error.rs"],"content":"use serde::de;\nuse std::fmt::{self, Debug, Display, Formatter};\nuse thiserror::Error;\n\n#[derive(Debug, Clone, Error, PartialEq)]\npub enum ErrorKind {\n\t#[error(\"{0}\")]\n\tMessage(String),\n\n\t/// This error will be returned if you request to deserialize anything but a\n\t/// struct at root level.\n\t#[error(\"Expected to deserialize a struct at root level\")]\n\tExpectedStruct,\n\n\t/// This error will be returned if the input ends unexpectedly.\n\t#[error(\"Unexpected end of input\")]\n\tEof,\n\n\t/// This error will be returned if an opening s-expr was expected, but some\n\t/// other token was found.\n\t#[error(\"Expected s-expr, found token '{0}'\")]\n\tExpectedSExpr(char),\n\n\t/// This error will be returned if an opening s-expr with a certain name was\n\t/// expected, but some other token was found.\n\t#[error(\"Expected s-expr identifier {0}, found {1}\")]\n\tExpectedSExprIdentifier(&'static str, String),\n\n\t/// This error will be returned if the end of the s-expr was expected, but some\n\t/// other token was found.\n\t#[error(\"Expected end of expression\")]\n\tExpectedEoe,\n\n\t/// This error will be returned if an identifier was expected, but some other\n\t/// token was found.\n\t#[error(\"Expected identifier\")]\n\tExpectedIdentifier,\n\n\t/// This error will be returned if a number was expected, but some other token\n\t/// was found.\n\t#[error(\"Expected number\")]\n\tExpectedNumber,\n\n\t/// This error will be returned if a string was expected, but some other token\n\t/// was found.\n\t#[error(\"Expected string\")]\n\tExpectedString,\n\n\t/// This error will be returned if an option was requested. [`Option`] is\n\t/// **not supported** by this data format.\n\t#[error(\"std::option::Option cannot be deserialized by this data format\")]\n\tDeserializeOption,\n\n\t/// This error will be returned if an s-expr is found, but its name (and fields)\n\t/// were not supplied to the deserializer (e.g. `deserialize_any` was called).\n\t#[error(\"Missing s-expr type info for {0}\")]\n\tMissingSExprInfo(String),\n\n\t/// This error will be returned when attempting to deserialize a non-newtype\n\t/// enum variant in a tagged way.\n\t#[error(\"Non-newtype enum variants are not supported in tagged format\")]\n\tNonNewtypeEnumVariant,\n\n\t/// This error will be returned when attempting to deserialize a non-unit enum\n\t/// variant in an untagged way.\n\t#[error(\"Non-unit enum variants are not supported in untagged format\")]\n\tNonUnitEnumVariant,\n\n\t/// This error will be returned if there were trailing tokens after the deserialization\n\t/// finished.\n\t#[error(\"Trailing tokens\")]\n\tTrailingTokens\n}\n\n#[non_exhaustive]\npub struct Error {\n\tpub kind: ErrorKind,\n\n\t#[cfg(feature = \"backtrace\")]\n\tpub(super) backtrace: once_cell::sync::Lazy<\n\t\tbacktrace::Backtrace,\n\t\tBox<dyn FnOnce() -> backtrace::Backtrace>\n\t>\n}\n\nimpl Error {\n\t#[cfg(feature = \"backtrace\")]\n\tpub fn backtrace(&self) -> &backtrace::Backtrace {\n\t\t&*self.backtrace\n\t}\n}\n\nimpl Debug for Error {\n\tfn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n\t\tlet mut dbg = f.debug_struct(\"Error\");\n\t\tdbg.field(\"message\", &self.kind.to_string());\n\t\tdbg.field(\"kind\", &self.kind);\n\t\t#[cfg(feature = \"backtrace\")]\n\t\tdbg.field(\"backtrace\", self.backtrace());\n\t\tdbg.finish()\n\t}\n}\n\nimpl Display for Error {\n\tfn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n\t\tDisplay::fmt(&self.kind, f)\n\t}\n}\n\nimpl std::error::Error for Error {}\n\nimpl de::Error for Error {\n\tfn custom<T: Display>(msg: T) -> Self {\n\t\tError {\n\t\t\tkind: ErrorKind::Message(msg.to_string()),\n\t\t\t#[cfg(feature = \"backtrace\")]\n\t\t\tbacktrace: {\n\t\t\t\tlet bt = backtrace::Backtrace::new_unresolved();\n\t\t\t\tonce_cell::sync::Lazy::new(Box::new(move || {\n\t\t\t\t\tlet mut bt = bt;\n\t\t\t\t\tbt.resolve();\n\t\t\t\t\tbt\n\t\t\t\t}))\n\t\t\t}\n\t\t}\n\t}\n}\n","traces":[{"line":94,"address":[164484,164304],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":95,"address":[164336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[164392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[164501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[164531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[164560],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":106,"address":[164574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[213888,213744,213858,213994],"length":1,"stats":{"Line":1},"fn_name":"custom<&alloc::string::String>"},{"line":115,"address":[213773,213901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":10},{"path":["/","home","runner","work","serde_kicad_sexpr","serde_kicad_sexpr","src","de","mod.rs"],"content":"use paste::paste;\nuse serde::{\n\tde::{\n\t\tself, DeserializeSeed, EnumAccess, MapAccess, SeqAccess, VariantAccess,\n\t\tVisitor\n\t},\n\tforward_to_deserialize_any, Deserialize\n};\nuse std::{borrow::Cow, fmt::Display, str::FromStr};\n\nmod error;\npub use error::{Error, ErrorKind};\n\nmacro_rules! error {\n\t($kind:ident $(($($arg:expr),+))?) => {\n\t\t{\n\t\t\tError {\n\t\t\t\tkind: ErrorKind::$kind $(($($arg),+))?,\n\t\t\t\t#[cfg(feature = \"backtrace\")]\n\t\t\t\tbacktrace: {\n\t\t\t\t\tlet bt = backtrace::Backtrace::new_unresolved();\n\t\t\t\t\tonce_cell::sync::Lazy::new(Box::new(move || {\n\t\t\t\t\t\tlet mut bt = bt;\n\t\t\t\t\t\tbt.resolve();\n\t\t\t\t\t\tbt\n\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\nmacro_rules! bail {\n\t($($body:tt)*) => {\n\t\treturn Err(error!($($body)*));\n\t};\n}\n\npub struct Deserializer<'de> {\n\tinput: &'de str\n}\n\nimpl<'de> Deserializer<'de> {\n\tpub fn from_str(input: &'de str) -> Self {\n\t\tSelf { input }\n\t}\n}\n\ntype Result<T, E = Error> = std::result::Result<T, E>;\n\npub fn from_str<'de, T>(input: &'de str) -> Result<T>\nwhere\n\tT: Deserialize<'de>\n{\n\tlet mut deserializer = Deserializer::from_str(input);\n\tlet value = T::deserialize(&mut deserializer)?;\n\tOk(value)\n}\n\nenum Token {\n\tString,\n\tInt,\n\tFloat,\n\tSExpr\n}\n\nimpl<'de> Deserializer<'de> {\n\tfn check_no_trailing_tokens(&mut self) -> Result<()> {\n\t\tself.skip_whitespace();\n\t\tif !self.input.is_empty() {\n\t\t\tbail!(TrailingTokens);\n\t\t}\n\t\tOk(())\n\t}\n\n\tfn skip_whitespace(&mut self) {\n\t\tself.input = self.input.trim_start();\n\t}\n\n\tfn peek_char(&self) -> Result<char> {\n\t\tself.input.chars().next().ok_or_else(|| error!(Eof))\n\t}\n\n\tfn next_char(&mut self) -> Result<char> {\n\t\tlet ch = self.peek_char()?;\n\t\tself.input = &self.input[ch.len_utf8()..];\n\t\tOk(ch)\n\t}\n\n\tfn peek_token(&self) -> Result<Token> {\n\t\tlet mut chars = self.input.chars().peekable();\n\t\tif chars.peek().is_none() {\n\t\t\tbail!(Eof);\n\t\t}\n\n\t\tlet mut int = true;\n\t\twhile let Some(ch) = chars.next() {\n\t\t\tmatch ch {\n\t\t\t\t'(' => return Ok(Token::SExpr),\n\t\t\t\t'.' => {\n\t\t\t\t\tint = false;\n\t\t\t\t},\n\t\t\t\t'-' => {},\n\t\t\t\tch if ch.is_ascii_whitespace() => break,\n\t\t\t\tch if ch.is_ascii_digit() => {},\n\t\t\t\t_ => return Ok(Token::String)\n\t\t\t};\n\t\t}\n\n\t\tOk(match int {\n\t\t\ttrue => Token::Int,\n\t\t\tfalse => Token::Float\n\t\t})\n\t}\n\n\tfn peek_identifier(&self) -> Option<&'de str> {\n\t\tlet len: usize = self\n\t\t\t.input\n\t\t\t.chars()\n\t\t\t.take_while(|ch| ch.is_ascii_alphabetic() || *ch == '_')\n\t\t\t.map(|ch| ch.len_utf8())\n\t\t\t.sum();\n\t\tif len == 0 {\n\t\t\treturn None;\n\t\t}\n\t\tSome(&self.input[..len])\n\t}\n\n\tfn peek_sexpr_identifier(&self) -> Result<&'de str> {\n\t\tlet mut chars = self.input.chars();\n\t\tlet next = chars.next().ok_or_else(|| error!(Eof))?;\n\t\tif next != '(' {\n\t\t\tbail!(ExpectedSExpr(next));\n\t\t}\n\t\tlet paren = '('.len_utf8();\n\t\tlet len: usize = chars\n\t\t\t.take_while(|ch| ch.is_ascii_alphabetic() || *ch == '_')\n\t\t\t.map(|ch| ch.len_utf8())\n\t\t\t.sum();\n\t\tif len == 0 {\n\t\t\tbail!(ExpectedIdentifier);\n\t\t}\n\t\tOk(&self.input[paren..paren + len])\n\t}\n\n\tfn consume(&mut self, len: usize) -> Result<()> {\n\t\tif self.input.len() < len {\n\t\t\tbail!(Eof);\n\t\t}\n\t\tself.input = &self.input[len..];\n\t\tOk(())\n\t}\n\n\tfn parse_number<T>(&mut self) -> Result<T>\n\twhere\n\t\tT: FromStr,\n\t\tT::Err: Display\n\t{\n\t\tlet len = self\n\t\t\t.input\n\t\t\t.chars()\n\t\t\t.take_while(|ch| !ch.is_ascii_whitespace() && *ch != ')')\n\t\t\t.map(|ch| ch.len_utf8())\n\t\t\t.sum();\n\t\tif len == 0 {\n\t\t\tbail!(ExpectedNumber);\n\t\t}\n\t\tlet number = &self.input[..len];\n\t\tlet number = number\n\t\t\t.parse()\n\t\t\t.map_err(|err: T::Err| error!(Message(err.to_string())))?;\n\t\tself.input = &self.input[len..];\n\t\tOk(number)\n\t}\n\n\tfn parse_string(&mut self) -> Result<Cow<'de, str>> {\n\t\tmatch self.peek_char()? {\n\t\t\t'(' => Err(error!(ExpectedString)),\n\n\t\t\t'\"' => {\n\t\t\t\tself.consume('\"'.len_utf8())?;\n\t\t\t\tlet mut value = String::new();\n\t\t\t\tloop {\n\t\t\t\t\tlet len: usize = self\n\t\t\t\t\t\t.input\n\t\t\t\t\t\t.chars()\n\t\t\t\t\t\t.take_while(|ch| *ch != '\"')\n\t\t\t\t\t\t.map(|ch| ch.len_utf8())\n\t\t\t\t\t\t.sum();\n\t\t\t\t\tif len >= self.input.len() {\n\t\t\t\t\t\tbail!(Eof);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet mut start_idx = value.chars().count();\n\t\t\t\t\tvalue += &self.input[..len + 1];\n\t\t\t\t\tself.input = &self.input[len + 1..];\n\t\t\t\t\twhile let Some(idx) = (&value[start_idx..]).find(r\"\\\\\") {\n\t\t\t\t\t\tlet idx = start_idx + idx;\n\t\t\t\t\t\tvalue.replace_range(idx..idx + 2, r\"\\\");\n\t\t\t\t\t\tstart_idx = idx + 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif value.ends_with(r#\"\\\"\"#) && start_idx < value.len() - 1 {\n\t\t\t\t\t\tvalue.remove(value.len() - 2);\n\t\t\t\t\t} else if value.ends_with(r#\"\"\"#) {\n\t\t\t\t\t\tvalue.remove(value.len() - 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunreachable!();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tOk(value.into())\n\t\t\t},\n\n\t\t\t_ => {\n\t\t\t\tlet len = self\n\t\t\t\t\t.input\n\t\t\t\t\t.chars()\n\t\t\t\t\t.take_while(|ch| !ch.is_ascii_whitespace() && *ch != ')')\n\t\t\t\t\t.map(|ch| ch.len_utf8())\n\t\t\t\t\t.sum();\n\t\t\t\tif len == 0 {\n\t\t\t\t\tbail!(Eof);\n\t\t\t\t}\n\t\t\t\tlet value = &self.input[..len];\n\t\t\t\tself.input = &self.input[len..];\n\t\t\t\tOk(value.into())\n\t\t\t}\n\t\t}\n\t}\n}\n\nimpl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n\ttype Error = Error;\n\n\tfn deserialize_any<V>(self, _: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tErr(error!(ExpectedStruct))\n\t}\n\n\tfn deserialize_struct<V>(\n\t\tself,\n\t\tname: &'static str,\n\t\tfields: &'static [&'static str],\n\t\tvisitor: V\n\t) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tlet v = visitor.visit_map(SExpr::new(self, name, fields)?)?;\n\t\tself.check_no_trailing_tokens()?;\n\t\tOk(v)\n\t}\n\n\tfn deserialize_unit_struct<V>(\n\t\tself,\n\t\tname: &'static str,\n\t\tvisitor: V\n\t) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tSExpr::consume_beginning(self, name)?;\n\t\tif self.next_char()? != ')' {\n\t\t\tbail!(ExpectedEoe);\n\t\t}\n\t\tself.check_no_trailing_tokens()?;\n\t\tvisitor.visit_unit()\n\t}\n\n\tfn deserialize_newtype_struct<V>(\n\t\tself,\n\t\tname: &'static str,\n\t\tvisitor: V\n\t) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tlet v = visitor.visit_seq(SExprTuple::new(self, name)?)?;\n\t\tself.check_no_trailing_tokens()?;\n\t\tOk(v)\n\t}\n\n\tfn deserialize_tuple_struct<V>(\n\t\tself,\n\t\tname: &'static str,\n\t\t_len: usize,\n\t\tvisitor: V\n\t) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tlet v = visitor.visit_seq(SExprTuple::new(self, name)?)?;\n\t\tself.check_no_trailing_tokens()?;\n\t\tOk(v)\n\t}\n\n\tfn deserialize_enum<V>(\n\t\tself,\n\t\t_name: &'static str,\n\t\t_variants: &'static [&'static str],\n\t\tvisitor: V\n\t) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tlet v = visitor.visit_enum(Enum::new(self))?;\n\t\tself.check_no_trailing_tokens()?;\n\t\tOk(v)\n\t}\n\n\tforward_to_deserialize_any! {\n\t\tbool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n\t\tbytes byte_buf option unit seq tuple map identifier ignored_any\n\t}\n}\n\n/// Deserialize an enum with only newtype variants whose variant names match the\n/// names of the contained s-exprs.\nstruct Enum<'a, 'de> {\n\tde: &'a mut Deserializer<'de>\n}\n\nimpl<'a, 'de> Enum<'a, 'de> {\n\tfn new(de: &'a mut Deserializer<'de>) -> Self {\n\t\tSelf { de }\n\t}\n}\n\nimpl<'a, 'de> EnumAccess<'de> for Enum<'a, 'de> {\n\ttype Error = Error;\n\ttype Variant = Self;\n\n\tfn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant)>\n\twhere\n\t\tV: DeserializeSeed<'de>\n\t{\n\t\tOk((\n\t\t\tseed.deserialize(FieldIdent(self.de.peek_sexpr_identifier()?))?,\n\t\t\tself\n\t\t))\n\t}\n}\n\nimpl<'a, 'de> VariantAccess<'de> for Enum<'a, 'de> {\n\ttype Error = Error;\n\n\tfn unit_variant(self) -> Result<(), Self::Error> {\n\t\tErr(error!(NonNewtypeEnumVariant))\n\t}\n\n\tfn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n\twhere\n\t\tT: DeserializeSeed<'de>\n\t{\n\t\tseed.deserialize(self.de)\n\t}\n\n\tfn tuple_variant<V>(\n\t\tself,\n\t\t_len: usize,\n\t\t_visitor: V\n\t) -> Result<V::Value, Self::Error>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tErr(error!(NonNewtypeEnumVariant))\n\t}\n\n\tfn struct_variant<V>(\n\t\tself,\n\t\t_fields: &'static [&'static str],\n\t\t_visitor: V\n\t) -> Result<V::Value, Self::Error>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tErr(error!(NonNewtypeEnumVariant))\n\t}\n}\n\n/// Deserialise an s-expr.\nstruct SExpr<'a, 'de> {\n\tde: &'a mut Deserializer<'de>,\n\tfields: &'static [&'static str],\n\tindex: usize,\n\tskip_to: Option<usize>\n}\n\nimpl<'a, 'de> SExpr<'a, 'de> {\n\tfn consume_beginning(\n\t\tde: &mut Deserializer<'de>,\n\t\tname: &'static str\n\t) -> Result<()> {\n\t\tde.skip_whitespace();\n\t\tlet peek = de.peek_sexpr_identifier()?;\n\t\tif peek != name {\n\t\t\tbail!(ExpectedSExprIdentifier(name, peek.to_owned()));\n\t\t}\n\t\tde.consume(name.len() + '('.len_utf8())?;\n\t\tOk(())\n\t}\n\n\tfn new(\n\t\tde: &'a mut Deserializer<'de>,\n\t\tname: &'static str,\n\t\tfields: &'static [&'static str]\n\t) -> Result<Self> {\n\t\tSelf::consume_beginning(de, name)?;\n\t\tOk(Self {\n\t\t\tde,\n\t\t\tfields,\n\t\t\tindex: 0,\n\t\t\tskip_to: None\n\t\t})\n\t}\n\n\tfn check_eoe(&mut self) -> Result<()> {\n\t\tself.de.skip_whitespace();\n\t\tif self.skip_to.is_none() && self.de.peek_char()? == ')' {\n\t\t\tself.de.consume(1)?;\n\t\t\t// technically we're done, but there could be booleans that are false, so we'll\n\t\t\t// deserialize those as None/false eventhough they don't exist in the input.\n\t\t\tself.skip_to = Some(self.fields.len() + 1);\n\t\t}\n\t\tOk(())\n\t}\n\n\tfn next_value_seed_impl<T>(&mut self, seed: T) -> Result<T::Value>\n\twhere\n\t\tT: DeserializeSeed<'de>\n\t{\n\t\tif self.index >= self.fields.len() {\n\t\t\tpanic!(\"There was no key and there is no value\");\n\t\t}\n\n\t\t// booleans are represented in this weird way where they are simply missing if they are\n\t\t// false. This means that if we detect a boolean ahead of our current index, we'll assume\n\t\t// everything inbetween is either None or false, and skip ahead.\n\t\tif let Some(skip_to) = self.skip_to {\n\t\t\tif skip_to == self.index {\n\t\t\t\tself.skip_to = None;\n\t\t\t\treturn seed.deserialize(TrueField);\n\t\t\t}\n\t\t\treturn seed.deserialize(MissingField);\n\t\t}\n\t\tif let Some(identifier) = self.de.peek_identifier() {\n\t\t\tif self.fields[self.index] == identifier {\n\t\t\t\tself.de.consume(identifier.len())?;\n\t\t\t\treturn seed.deserialize(TrueField);\n\t\t\t}\n\t\t\tfor i in self.index + 1..self.fields.len() {\n\t\t\t\tif self.fields[i] == identifier {\n\t\t\t\t\tself.de.consume(identifier.len())?;\n\t\t\t\t\tself.skip_to = Some(i);\n\t\t\t\t\treturn seed.deserialize(MissingField);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tseed.deserialize(Field::new(self.de, Some(self.fields[self.index])))\n\t}\n}\n\nimpl<'a, 'de> MapAccess<'de> for SExpr<'a, 'de> {\n\ttype Error = Error;\n\n\tfn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>>\n\twhere\n\t\tK: DeserializeSeed<'de>\n\t{\n\t\tself.check_eoe()?;\n\n\t\tloop {\n\t\t\tif self.index >= self.fields.len() {\n\t\t\t\treturn Ok(None);\n\t\t\t}\n\n\t\t\t// special case: if the ident is empty (\"\") and we are set to skip it, don't even\n\t\t\t// return the field.\n\t\t\tif self.fields[self.index] == \"\" {\n\t\t\t\tif let Some(skip_to) = self.skip_to {\n\t\t\t\t\tif skip_to == self.index {\n\t\t\t\t\t\tself.skip_to = None;\n\t\t\t\t\t}\n\t\t\t\t\tself.index += 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tseed.deserialize(FieldIdent(self.fields[self.index]))\n\t\t\t.map(Some)\n\t}\n\n\tfn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value>\n\twhere\n\t\tT: DeserializeSeed<'de>\n\t{\n\t\tlet value = self.next_value_seed_impl(seed)?;\n\t\tself.index += 1;\n\t\tself.check_eoe()?;\n\t\tOk(value)\n\t}\n}\n\n/// Deserialize an s-expr in tuple format. It cannot contain booleans.\nstruct SExprTuple<'a, 'de> {\n\tde: &'a mut Deserializer<'de>,\n\tend: bool\n}\n\nimpl<'a, 'de> SExprTuple<'a, 'de> {\n\tfn new(de: &'a mut Deserializer<'de>, name: &'static str) -> Result<Self> {\n\t\tSExpr::consume_beginning(de, name)?;\n\t\tOk(Self { de, end: false })\n\t}\n\n\tfn check_eoe(&mut self) -> Result<()> {\n\t\tif self.end {\n\t\t\treturn Ok(());\n\t\t}\n\n\t\tself.de.skip_whitespace();\n\t\tif self.de.peek_char()? == ')' {\n\t\t\tself.de.consume(')'.len_utf8())?;\n\t\t\tself.end = true;\n\t\t}\n\t\tOk(())\n\t}\n}\n\nimpl<'a, 'de> SeqAccess<'de> for SExprTuple<'a, 'de> {\n\ttype Error = Error;\n\n\tfn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>\n\twhere\n\t\tT: DeserializeSeed<'de>\n\t{\n\t\tself.check_eoe()?;\n\t\tif self.end {\n\t\t\treturn Ok(None);\n\t\t}\n\t\tlet value = seed.deserialize(Field::new(self.de, None))?;\n\t\tself.check_eoe()?;\n\t\tOk(Some(value))\n\t}\n}\n\n/// Deserialize a field's ident.\nstruct FieldIdent<'a>(&'a str);\n\nimpl<'a, 'de> de::Deserializer<'de> for FieldIdent<'a>\nwhere\n\t'a: 'de\n{\n\ttype Error = Error;\n\n\tfn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_borrowed_str(self.0)\n\t}\n\n\tforward_to_deserialize_any! {\n\t\tbool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n\t\tbytes byte_buf option unit unit_struct newtype_struct seq tuple\n\t\ttuple_struct map struct enum identifier ignored_any\n\t}\n}\n\n/// Deserialize a single boolean with value `true`.\nstruct TrueField;\n\nimpl<'de> de::Deserializer<'de> for TrueField {\n\ttype Error = Error;\n\n\tfn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_bool(true)\n\t}\n\n\tforward_to_deserialize_any! {\n\t\tbool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n\t\tbytes byte_buf option unit unit_struct newtype_struct seq tuple\n\t\ttuple_struct map struct enum identifier ignored_any\n\t}\n}\n\n/// Deserialize either a boolean with value `false` or an option with value `None`.\nstruct MissingField;\n\nimpl<'de> de::Deserializer<'de> for MissingField {\n\ttype Error = Error;\n\n\tfn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_none()\n\t}\n\n\tfn deserialize_bool<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_bool(false)\n\t}\n\n\tforward_to_deserialize_any! {\n\t\ti8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n\t\tbytes byte_buf option unit unit_struct newtype_struct seq tuple\n\t\ttuple_struct map struct enum identifier ignored_any\n\t}\n}\n\n/// A field whose value does not match its ident. This means that if a boolean gets requested,\n/// we must return false without touching the input.\n///\n/// We still store the ident if we know it, so that we can parse a sequence like\n/// (<ident> <values..>). The empty ident (`\"\"`) is treated as a special case to consume\n/// the remaining fields of the current expression.\nstruct Field<'a, 'de> {\n\tde: &'a mut Deserializer<'de>,\n\tident: Option<&'static str>\n}\n\nimpl<'a, 'de> Field<'a, 'de> {\n\tfn new(de: &'a mut Deserializer<'de>, ident: Option<&'static str>) -> Self {\n\t\tSelf { de, ident }\n\t}\n}\n\nmacro_rules! forward_to_parse_number {\n\t($($ident:ident)+) => {\n\t\t$(\n\t\t\tpaste! {\n\t\t\t\tfn [<deserialize_ $ident>]<V>(self, visitor: V) -> Result<V::Value>\n\t\t\t\twhere\n\t\t\t\t\tV: Visitor<'de>\n\t\t\t\t{\n\t\t\t\t\tvisitor.[<visit_ $ident>](self.de.parse_number()?)\n\t\t\t\t}\n\t\t\t}\n\t\t)+\n\t};\n}\n\nimpl<'a, 'de> de::Deserializer<'de> for Field<'a, 'de> {\n\ttype Error = Error;\n\n\tfn deserialize_any<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tmatch self.de.peek_token()? {\n\t\t\tToken::Int if self.de.peek_char()? == '-' => {\n\t\t\t\tself.deserialize_i64(visitor)\n\t\t\t},\n\t\t\tToken::Int => self.deserialize_u64(visitor),\n\t\t\tToken::Float => self.deserialize_f64(visitor),\n\t\t\tToken::String => self.deserialize_string(visitor),\n\t\t\tToken::SExpr if Some(self.de.peek_sexpr_identifier()?) == self.ident => {\n\t\t\t\tself.deserialize_seq(visitor)\n\t\t\t},\n\t\t\tToken::SExpr => Err(error!(MissingSExprInfo(\n\t\t\t\tself.de.peek_sexpr_identifier()?.to_owned()\n\t\t\t)))\n\t\t}\n\t}\n\n\tfn deserialize_bool<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_bool(false)\n\t}\n\n\tfn deserialize_str<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tself.deserialize_string(visitor)\n\t}\n\n\tfn deserialize_string<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tlet value = self.de.parse_string()?;\n\t\tmatch value {\n\t\t\tCow::Borrowed(value) => visitor.visit_borrowed_str(value),\n\t\t\tCow::Owned(value) => visitor.visit_string(value)\n\t\t}\n\t}\n\n\tfn deserialize_option<V>(self, _visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\t// we'll need to know the type of Some (i.e. the s-expr tag) to see if it is present in\n\t\t// the input or not\n\t\t// however, serde doesn't give us this type of information, so we'll just error\n\t\tErr(error!(DeserializeOption))\n\t}\n\n\tfn deserialize_struct<V>(\n\t\tself,\n\t\tname: &'static str,\n\t\tfields: &'static [&'static str],\n\t\tvisitor: V\n\t) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_map(SExpr::new(self.de, name, fields)?)\n\t}\n\n\tfn deserialize_unit<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tlet ident = match self.ident {\n\t\t\tSome(ident) => ident,\n\t\t\tNone => {\n\t\t\t\tbail!(MissingSExprInfo(\n\t\t\t\t\tself.de.peek_sexpr_identifier()?.to_owned()\n\t\t\t\t));\n\t\t\t}\n\t\t};\n\t\tself.deserialize_unit_struct(ident, visitor)\n\t}\n\n\tfn deserialize_unit_struct<V>(\n\t\tself,\n\t\tname: &'static str,\n\t\tvisitor: V\n\t) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tSExpr::consume_beginning(self.de, name)?;\n\t\tif self.de.next_char()? != ')' {\n\t\t\tbail!(ExpectedEoe);\n\t\t}\n\t\tvisitor.visit_unit()\n\t}\n\n\tfn deserialize_newtype_struct<V>(\n\t\tself,\n\t\tname: &'static str,\n\t\tvisitor: V\n\t) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tself.deserialize_tuple_struct(name, 1, visitor)\n\t}\n\n\tfn deserialize_tuple_struct<V>(\n\t\tself,\n\t\tname: &'static str,\n\t\t_len: usize,\n\t\tvisitor: V\n\t) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_seq(SExprTuple::new(self.de, name)?)\n\t}\n\n\tfn deserialize_enum<V>(\n\t\tself,\n\t\t_name: &'static str,\n\t\t_variants: &'static [&'static str],\n\t\tvisitor: V\n\t) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tvisitor.visit_enum(self)\n\t}\n\n\tfn deserialize_seq<V>(self, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tlet ident = match self.ident {\n\t\t\tSome(ident) => ident,\n\t\t\tNone => {\n\t\t\t\tbail!(MissingSExprInfo(\n\t\t\t\t\tself.de.peek_sexpr_identifier()?.to_owned()\n\t\t\t\t));\n\t\t\t}\n\t\t};\n\t\tmatch ident {\n\t\t\t\"\" => {\n\t\t\t\t// special case: we'll return the remaining tokens of the current s-expr\n\t\t\t\tvisitor.visit_seq(self)\n\t\t\t},\n\t\t\t_ => visitor.visit_seq(SExprTuple::new(self.de, ident)?)\n\t\t}\n\t}\n\n\tfn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tself.deserialize_seq(visitor)\n\t}\n\n\tforward_to_parse_number! {\n\t\ti8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64\n\t}\n\n\tforward_to_deserialize_any! {\n\t\tchar bytes byte_buf map identifier ignored_any\n\t}\n}\n\nimpl<'a, 'de> SeqAccess<'de> for Field<'a, 'de> {\n\ttype Error = Error;\n\n\tfn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>>\n\twhere\n\t\tT: DeserializeSeed<'de>\n\t{\n\t\tself.de.skip_whitespace();\n\t\tif self.de.peek_char()? == ')' {\n\t\t\treturn Ok(None);\n\t\t}\n\t\tseed.deserialize(Field::new(self.de, None)).map(Some)\n\t}\n}\n\nimpl<'a, 'de> EnumAccess<'de> for Field<'a, 'de> {\n\ttype Error = Error;\n\ttype Variant = Either<UnitVariant, NewtypeVariant<'a, 'de>>;\n\n\tfn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant)>\n\twhere\n\t\tV: DeserializeSeed<'de>\n\t{\n\t\tOk(match self.de.peek_token()? {\n\t\t\tToken::SExpr => {\n\t\t\t\tlet str = self.de.peek_sexpr_identifier()?;\n\t\t\t\t(\n\t\t\t\t\tseed.deserialize(FieldIdent(str))?,\n\t\t\t\t\tEither::Right(NewtypeVariant { de: self.de })\n\t\t\t\t)\n\t\t\t},\n\t\t\t_ => (seed.deserialize(self)?, Either::Left(UnitVariant))\n\t\t})\n\t}\n}\n\n/// This will deserialize only unit variants.\nstruct UnitVariant;\n\nimpl<'de> VariantAccess<'de> for UnitVariant {\n\ttype Error = Error;\n\n\tfn unit_variant(self) -> Result<()> {\n\t\tOk(())\n\t}\n\n\tfn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value>\n\twhere\n\t\tT: DeserializeSeed<'de>\n\t{\n\t\tErr(error!(NonUnitEnumVariant))\n\t}\n\n\tfn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tErr(error!(NonUnitEnumVariant))\n\t}\n\n\tfn struct_variant<V>(\n\t\tself,\n\t\t_fields: &'static [&'static str],\n\t\t_visitor: V\n\t) -> Result<V::Value>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tErr(error!(NonUnitEnumVariant))\n\t}\n}\n\n/// This will deserialize only newtype variants.\nstruct NewtypeVariant<'a, 'de> {\n\tde: &'a mut Deserializer<'de>\n}\n\nimpl<'a, 'de> VariantAccess<'de> for NewtypeVariant<'a, 'de> {\n\ttype Error = Error;\n\n\tfn unit_variant(self) -> Result<(), Self::Error> {\n\t\tErr(error!(NonNewtypeEnumVariant))\n\t}\n\n\tfn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n\twhere\n\t\tT: DeserializeSeed<'de>\n\t{\n\t\tseed.deserialize(Field::new(self.de, None))\n\t}\n\n\tfn tuple_variant<V>(\n\t\tself,\n\t\t_len: usize,\n\t\t_visitor: V\n\t) -> Result<V::Value, Self::Error>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tErr(error!(NonNewtypeEnumVariant))\n\t}\n\n\tfn struct_variant<V>(\n\t\tself,\n\t\t_fields: &'static [&'static str],\n\t\t_visitor: V\n\t) -> Result<V::Value, Self::Error>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tErr(error!(NonNewtypeEnumVariant))\n\t}\n}\n\n/// An `Either` type for `VariantAccess`.\nenum Either<L, R> {\n\tLeft(L),\n\tRight(R)\n}\n\nimpl<'de, L, R> VariantAccess<'de> for Either<L, R>\nwhere\n\tL: VariantAccess<'de>,\n\tR: VariantAccess<'de, Error = L::Error>\n{\n\ttype Error = L::Error;\n\n\tfn unit_variant(self) -> Result<(), Self::Error> {\n\t\tmatch self {\n\t\t\tSelf::Left(l) => l.unit_variant(),\n\t\t\tSelf::Right(r) => r.unit_variant()\n\t\t}\n\t}\n\n\tfn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n\twhere\n\t\tT: DeserializeSeed<'de>\n\t{\n\t\tmatch self {\n\t\t\tSelf::Left(l) => l.newtype_variant_seed(seed),\n\t\t\tSelf::Right(r) => r.newtype_variant_seed(seed)\n\t\t}\n\t}\n\n\tfn tuple_variant<V>(\n\t\tself,\n\t\tlen: usize,\n\t\tvisitor: V\n\t) -> Result<V::Value, Self::Error>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tmatch self {\n\t\t\tSelf::Left(l) => l.tuple_variant(len, visitor),\n\t\t\tSelf::Right(r) => r.tuple_variant(len, visitor)\n\t\t}\n\t}\n\n\tfn struct_variant<V>(\n\t\tself,\n\t\tfields: &'static [&'static str],\n\t\tvisitor: V\n\t) -> Result<V::Value, Self::Error>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tmatch self {\n\t\t\tSelf::Left(l) => l.struct_variant(fields, visitor),\n\t\t\tSelf::Right(r) => r.struct_variant(fields, visitor)\n\t\t}\n\t}\n}\n","traces":[{"line":44,"address":[242928],"length":1,"stats":{"Line":4},"fn_name":"from_str"},{"line":51,"address":[173072],"length":1,"stats":{"Line":12},"fn_name":"from_str<serde_kicad_sexpr::untagged::tests::FooOrBar>"},{"line":55,"address":[173129],"length":1,"stats":{"Line":12},"fn_name":null},{"line":56,"address":[173233,173144],"length":1,"stats":{"Line":13},"fn_name":null},{"line":57,"address":[173222],"length":1,"stats":{"Line":13},"fn_name":null},{"line":68,"address":[242976],"length":1,"stats":{"Line":3},"fn_name":"check_no_trailing_tokens"},{"line":69,"address":[243014],"length":1,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[243024],"length":1,"stats":{"Line":4},"fn_name":null},{"line":71,"address":[243063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[243055],"length":1,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[243136],"length":1,"stats":{"Line":3},"fn_name":"skip_whitespace"},{"line":77,"address":[243153],"length":1,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[243216],"length":1,"stats":{"Line":4},"fn_name":"peek_char"},{"line":81,"address":[173328,173340],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":84,"address":[243296],"length":1,"stats":{"Line":3},"fn_name":"next_char"},{"line":85,"address":[243428,243326],"length":1,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[243399,243529],"length":1,"stats":{"Line":6},"fn_name":null},{"line":87,"address":[243598],"length":1,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[243616],"length":1,"stats":{"Line":2},"fn_name":"peek_token"},{"line":91,"address":[243641],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[243683],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[243732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[243722],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[243811,243730],"length":1,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[243875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[243974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[243994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[243986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[244044,243934,244003],"length":1,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[244131,244009,244108],"length":1,"stats":{"Line":4},"fn_name":null},{"line":106,"address":[244119],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[244086,243915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[244073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[244063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[244160],"length":1,"stats":{"Line":1},"fn_name":"peek_identifier"},{"line":117,"address":[244180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[173376,173406],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":121,"address":[173496,173472],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":123,"address":[244265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[244271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[244292],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[244368],"length":1,"stats":{"Line":4},"fn_name":"peek_sexpr_identifier"},{"line":130,"address":[244398],"length":1,"stats":{"Line":4},"fn_name":null},{"line":131,"address":[173532,173520],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":132,"address":[244506],"length":1,"stats":{"Line":4},"fn_name":null},{"line":133,"address":[244628],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[244599],"length":1,"stats":{"Line":4},"fn_name":null},{"line":136,"address":[244713],"length":1,"stats":{"Line":4},"fn_name":null},{"line":137,"address":[173598,173568],"length":1,"stats":{"Line":8},"fn_name":"{closure#1}"},{"line":138,"address":[173664,173688],"length":1,"stats":{"Line":8},"fn_name":"{closure#2}"},{"line":140,"address":[244788],"length":1,"stats":{"Line":4},"fn_name":null},{"line":141,"address":[244794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[244890],"length":1,"stats":{"Line":4},"fn_name":null},{"line":146,"address":[245072],"length":1,"stats":{"Line":4},"fn_name":"consume"},{"line":147,"address":[245115],"length":1,"stats":{"Line":4},"fn_name":null},{"line":148,"address":[245204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[245285,245157],"length":1,"stats":{"Line":8},"fn_name":null},{"line":151,"address":[245292],"length":1,"stats":{"Line":4},"fn_name":null},{"line":154,"address":[190972,191617,192304,191632,192284,193602,190320,190992,192918,192944],"length":1,"stats":{"Line":2},"fn_name":"parse_number<u64>"},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[245312,248271],"length":1,"stats":{"Line":2},"fn_name":"parse_string"},{"line":177,"address":[245351],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[245577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[245664,246177,246250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[246235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[246328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[246344,246462],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[173725,173712],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":188,"address":[173768,173744],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":190,"address":[246516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[246590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[246567,246731],"length":1,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[246817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[247008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[247184,248233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[247356,248031,248057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[248103,248039],"length":1,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[248238,248204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[247884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[245703,245547],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[173822,173792],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":220,"address":[173912,173888],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}"},{"line":222,"address":[245774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[245780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[245883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[245982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[246080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[274596,276724,275572,274432,276560,277568,275408,273588,277732,273424],"length":1,"stats":{"Line":6},"fn_name":"deserialize_struct<test::_::{impl#0}::deserialize::__Visitor>"},{"line":252,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":257,"address":[174788,174816,175668,173936],"length":1,"stats":{"Line":3},"fn_name":"deserialize_unit_struct<serde_kicad_sexpr::untagged::tests::foo_bar::_::{impl#0}::deserialize::__Visitor>"},{"line":265,"address":[174068,175101,174117,173982,174997,174221,174948,174862],"length":1,"stats":{"Line":6},"fn_name":null},{"line":266,"address":[174443,174269,174982,174102,175323,175149],"length":1,"stats":{"Line":6},"fn_name":null},{"line":267,"address":[175370,174490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[174630,174746,175363,175510,175451,174483,174571,175626],"length":1,"stats":{"Line":7},"fn_name":null},{"line":270,"address":[174607,175666,175487,174786],"length":1,"stats":{"Line":6},"fn_name":null},{"line":273,"address":[280384,280529,281328,281473],"length":1,"stats":{"Line":2},"fn_name":"deserialize_newtype_struct<test::_::{impl#0}::deserialize::__Visitor>"},{"line":281,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[279504,279657],"length":1,"stats":{"Line":1},"fn_name":"deserialize_tuple_struct<test::_::{impl#0}::deserialize::__Visitor>"},{"line":295,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[175962,175696],"length":1,"stats":{"Line":2},"fn_name":"deserialize_enum<serde_kicad_sexpr::untagged::tests::{impl#0}::deserialize::Visitor>"},{"line":309,"address":[175977,175834,176036],"length":1,"stats":{"Line":2},"fn_name":null},{"line":310,"address":[176138,176337,176172,176029,176221],"length":1,"stats":{"Line":6},"fn_name":null},{"line":311,"address":[176205],"length":1,"stats":{"Line":2},"fn_name":null},{"line":327,"address":[248304],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":336,"address":[176492,176368],"length":1,"stats":{"Line":2},"fn_name":"variant_seed<core::marker::PhantomData<alloc::borrow::Cow<str>>>"},{"line":340,"address":[176935,176397],"length":1,"stats":{"Line":4},"fn_name":null},{"line":341,"address":[176405,177013,176767,176507],"length":1,"stats":{"Line":4},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[248336],"length":1,"stats":{"Line":0},"fn_name":"unit_variant"},{"line":351,"address":[248354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[177136,177104],"length":1,"stats":{"Line":2},"fn_name":"newtype_variant_seed<core::marker::PhantomData<serde_kicad_sexpr::untagged::tests::foo_bar::Foo>>"},{"line":358,"address":[177152,177120],"length":1,"stats":{"Line":2},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[248416],"length":1,"stats":{"Line":3},"fn_name":"consume_beginning"},{"line":397,"address":[248464],"length":1,"stats":{"Line":3},"fn_name":null},{"line":398,"address":[248474,248582],"length":1,"stats":{"Line":4},"fn_name":null},{"line":399,"address":[248560,248672],"length":1,"stats":{"Line":8},"fn_name":null},{"line":400,"address":[248703],"length":1,"stats":{"Line":2},"fn_name":null},{"line":402,"address":[248885,248678,249041],"length":1,"stats":{"Line":8},"fn_name":null},{"line":403,"address":[249030],"length":1,"stats":{"Line":4},"fn_name":null},{"line":406,"address":[249120],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":411,"address":[249191,249375],"length":1,"stats":{"Line":3},"fn_name":null},{"line":412,"address":[249271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[249259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[249472],"length":1,"stats":{"Line":1},"fn_name":"check_eoe"},{"line":421,"address":[249502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[249515,249958,249707],"length":1,"stats":{"Line":3},"fn_name":null},{"line":423,"address":[249732,249829],"length":1,"stats":{"Line":1},"fn_name":null},{"line":426,"address":[249803,249914,249963],"length":1,"stats":{"Line":2},"fn_name":null},{"line":428,"address":[249719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":431,"address":[213611,221867,213648,223968,209483,225995,201264,195072,201227,205355,207419,211584,221904,219840,223931,197136,207456,209520,203328,203291,211547,197099,205392,215675,217739,217776,219803,199200,215712,199163],"length":1,"stats":{"Line":23},"fn_name":"next_value_seed_impl<core::marker::PhantomData<(f32, f32)>>"},{"line":435,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":470,"address":[235664,236580,233776,231888,234720,232832,236608,237524,233748,232804,235636,234692],"length":1,"stats":{"Line":8},"fn_name":"next_key_seed<core::marker::PhantomData<test::_::{impl#0}::deserialize::__Field>>"},{"line":474,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[241088,240528,244070,242800,246463,239392,243488,244096,238832,242179,239935,239952,245911,245248,240512,245231,245936,238812,242208,244686,239408,244704,238240,242780,241631,243465,241104,241648,238215,237552],"length":1,"stats":{"Line":23},"fn_name":"next_value_seed<core::marker::PhantomData<alloc::vec::Vec<alloc::string::String, alloc::alloc::Global>>>"},{"line":504,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":518,"address":[250000],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":519,"address":[250150,250045],"length":1,"stats":{"Line":2},"fn_name":null},{"line":520,"address":[250100],"length":1,"stats":{"Line":2},"fn_name":null},{"line":523,"address":[250240],"length":1,"stats":{"Line":2},"fn_name":"check_eoe"},{"line":524,"address":[250270],"length":1,"stats":{"Line":2},"fn_name":null},{"line":525,"address":[250296],"length":1,"stats":{"Line":2},"fn_name":null},{"line":528,"address":[250281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":529,"address":[250578,250320],"length":1,"stats":{"Line":3},"fn_name":null},{"line":530,"address":[250511,250580,250462],"length":1,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[250574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[250491],"length":1,"stats":{"Line":2},"fn_name":null},{"line":540,"address":[269155,267920,269200,267887,270272,266592],"length":1,"stats":{"Line":3},"fn_name":"next_element_seed<core::marker::PhantomData<test::Pad>>"},{"line":544,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":563,"address":[177168],"length":1,"stats":{"Line":11},"fn_name":"deserialize_any<serde::de::impls::StringVisitor>"},{"line":567,"address":[177190],"length":1,"stats":{"Line":11},"fn_name":null},{"line":583,"address":[270448,270352,270832,270480,270512,270624,270416,270736,270656,270592,270544,270304,270384,270784,270688],"length":1,"stats":{"Line":1},"fn_name":"deserialize_any<serde_kicad_sexpr::option::OptionVisitor<test::_::{impl#0}::deserialize::__Visitor>>"},{"line":587,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":603,"address":[272288,272384,272576,272480,272672,272448,272608,272512,272320,272416,272544,272640,272352,272256],"length":1,"stats":{"Line":4},"fn_name":"deserialize_any<serde_kicad_sexpr::option::OptionVisitor<test::_::{impl#0}::deserialize::__Visitor>>"},{"line":607,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":610,"address":[272864],"length":1,"stats":{"Line":1},"fn_name":"deserialize_bool<serde::de::impls::BoolVisitor>"},{"line":614,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":636,"address":[250656],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":645,"address":[252819,254480,253526,253174,260534,254582,252368,252469,253072,254144,252704,253424,254246,260096,253892,260198,260432,253776],"length":1,"stats":{"Line":3},"fn_name":"deserialize_f32<serde::de::impls::{impl#52}::deserialize::PrimitiveVisitor>"},{"line":649,"address":[260549,254597,253088,254120,253541,254261,260752,252484,253806,252384,253440,260448,253394,253046,252734,254464,254474,253746,260426,253907,253189,253756,253056,260762,260213,254496,252834,254160,260112,260416,253404,252689,254800,254810,254130,252699],"length":1,"stats":{"Line":6},"fn_name":null},{"line":659,"address":[252336,250720,249072,250688],"length":1,"stats":{"Line":4},"fn_name":"deserialize_any<test::_::{impl#0}::deserialize::__FieldVisitor>"},{"line":663,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":670,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":673,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":679,"address":[260768],"length":1,"stats":{"Line":1},"fn_name":"deserialize_bool<serde::de::impls::BoolVisitor>"},{"line":683,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[261648,262272,262871,263495,262896,262247],"length":1,"stats":{"Line":6},"fn_name":"deserialize_string<test::_::{impl#0}::deserialize::__FieldVisitor>"},{"line":697,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":714,"address":[264448,263658,263968,264129,263520,264586],"length":1,"stats":{"Line":6},"fn_name":"deserialize_struct<test::_::{impl#0}::deserialize::__Visitor>"},{"line":723,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":726,"address":[260960,261558],"length":1,"stats":{"Line":1},"fn_name":"deserialize_unit<serde_kicad_sexpr::option::OptionVisitor<serde::de::impls::UnitVisitor>>"},{"line":730,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":741,"address":[265696,265024],"length":1,"stats":{"Line":1},"fn_name":"deserialize_unit_struct<serde_kicad_sexpr::option::OptionVisitor<serde::de::impls::UnitVisitor>>"},{"line":749,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":751,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":756,"address":[266512],"length":1,"stats":{"Line":0},"fn_name":"deserialize_newtype_struct<serde_kicad_sexpr::option::OptionVisitor<test::_::{impl#0}::deserialize::__Visitor>>"},{"line":764,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[266258,265872,265728,266128],"length":1,"stats":{"Line":1},"fn_name":"deserialize_tuple_struct<serde_kicad_sexpr::option::OptionVisitor<test::_::{impl#0}::deserialize::__Visitor>>"},{"line":776,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":779,"address":[260880,260800],"length":1,"stats":{"Line":4},"fn_name":"deserialize_enum<test::_::{impl#0}::deserialize::__Visitor>"},{"line":788,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":791,"address":[256928,257984,256906,255872,257958,255850,259014,254816,259040,260073],"length":1,"stats":{"Line":6},"fn_name":"deserialize_seq<serde::de::impls::{impl#19}::deserialize::VecVisitor<alloc::string::String>>"},{"line":795,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":806,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":808,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":812,"address":[261584],"length":1,"stats":{"Line":2},"fn_name":"deserialize_tuple<serde::de::impls::{impl#160}::deserialize::TupleVisitor<f32, f32>>"},{"line":816,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":831,"address":[231259,231296,230096,231857,230688,230653],"length":1,"stats":{"Line":2},"fn_name":"next_element_seed<core::marker::PhantomData<f32>>"},{"line":835,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":836,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":837,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":847,"address":[249025,246480,247729,247776],"length":1,"stats":{"Line":4},"fn_name":"variant_seed<core::marker::PhantomData<test::_::{impl#0}::deserialize::__Field>>"},{"line":851,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":852,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":856,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":870,"address":[250704],"length":1,"stats":{"Line":2},"fn_name":"unit_variant"},{"line":871,"address":[250708],"length":1,"stats":{"Line":2},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":896,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":908,"address":[250720],"length":1,"stats":{"Line":0},"fn_name":"unit_variant"},{"line":909,"address":[250738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":927,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":938,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":955,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":956,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":957,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":958,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":966,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":967,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":968,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":980,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":981,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":982,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":994,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":995,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":996,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":226,"coverable":309},{"path":["/","home","runner","work","serde_kicad_sexpr","serde_kicad_sexpr","src","lib.rs"],"content":"#![warn(rust_2018_idioms, unreachable_pub)]\n#![deny(elided_lifetimes_in_paths)]\n#![forbid(unsafe_code)]\n\n//! This crate provides a serde [`Serializer`] and [`Deserializer`] implementation for\n//! the S-Expression data format used by KiCAD. Since this format differs in some central\n//! aspects from other formats like JSON, there are some limitations and special cases\n//! you should be aware of:\n//!\n//!  - The name of your struct matters. For a simple struct like\n//!\n//!    ```rust\n//!    # use serde::{Deserialize, Serialize};\n//!    #[derive(Deserialize, Serialize)]\n//!    struct Point(i32, i32);\n//!    ```\n//!\n//!    and an example value `Point(1, 2)` you will get a JSON representation of\n//!    `[1, 2]` whereas this crate will output `(Point 1 2)`.\n//!\n//!  - The name of the fields also matters if the field's type is either a boolean,\n//!    a tuple or a sequence. These fields cannot appear in unnamed containers\n//!    (i.e. tuple structs).\n//!\n//!  - Deserializing `Option` is not supported, because we need to know the type inside\n//!    the option to determine if it is present or missing. To deserialize optional\n//!    values, use the custom deserializing logic from this crate:\n//!\n//!    ```rust\n//!    # use serde::{Deserialize, Serialize};\n//!    #[derive(Deserialize, Serialize)]\n//!    struct Position {\n//!        x: i32,\n//!        y: i32,\n//!        #[serde(with = \"serde_kicad_sexpr::Option\")]\n//!        rotation: Option<i32>\n//!    }\n//!    ```\n//!\n//!  - If you need to deserialize some sort of container with an unknown number of\n//!    children, use a special field with an empty name, like so:\n//!\n//!    ```rust\n//!    # use serde::{Deserialize, Serialize};\n//!    #[derive(Deserialize, Serialize)]\n//!    struct Point(i32, i32);\n//!\n//!    #[derive(Deserialize, Serialize)]\n//!    struct Polygon {\n//!        #[serde(default, rename = \"\")]\n//!        points: Vec<Point>\n//!    }\n//!    ```\n//!\n//!    Note that this has to be the last field of the struct. There must not be any\n//!    fields after a field with an empty name, and there must only be one field\n//!    with an empty name.\n//!\n//!  - Untagged enums are not supported. If you need to parse one from a number of\n//!    types, use the [`untagged!`] macro:\n//!\n//!    ```rust\n//!    serde_kicad_sexpr::untagged! {\n//!        enum TextOrNumber {\n//!            Text(String),\n//!            Int(i32),\n//!            Float(f32)\n//!        }\n//!    }\n//!    ```\n//!\n//!  [`Serializer`]: serde::ser::Serializer\n//!  [`Deserializer`]: serde::de::Deserializer\n//!  [`untagged!`]: serde_kicad_sexpr::untagged\n\nmod option;\n#[macro_use]\nmod untagged;\n\npub mod de;\n#[doc(hidden)]\npub mod private;\npub mod ser;\n\npub use de::from_str;\npub use option::{deserialize_option, OptionDef as Option};\npub use ser::{to_string, to_string_pretty};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","serde_kicad_sexpr","serde_kicad_sexpr","src","option.rs"],"content":"use serde::{\n\tde::{\n\t\tself, Deserialize, Deserializer, EnumAccess, MapAccess, SeqAccess, Visitor\n\t},\n\tser::{Serialize, Serializer}\n};\nuse std::{\n\tfmt::{self, Formatter},\n\tmarker::PhantomData\n};\n\n/// Deserialize an [`Option`] in a way that is supported by the s-expression format.\n///\n/// ### Example\n///\n/// ```rust\n/// # use serde::{Deserialize, Serialize};\n/// # #[derive(Debug, PartialEq)]\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(deny_unknown_fields, rename = \"size\")]\n/// struct Size(f32, f32);\n///\n/// # #[derive(Debug, PartialEq)]\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(deny_unknown_fields, rename = \"thickness\")]\n/// struct Thickness(f32);\n///\n/// # #[derive(Debug, PartialEq)]\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(deny_unknown_fields, rename = \"font\")]\n/// struct Font {\n/// \tsize: Size,\n///\n/// \t// This attribute enables our custom deserialize logic.\n/// \t#[serde(with = \"serde_kicad_sexpr::Option\")]\n/// \tthickness: Option<Thickness>,\n///\n/// \tbold: bool\n/// }\n/// # assert_eq!(\n/// # \tserde_kicad_sexpr::from_str::<Font>(\"(font (size 1 1) bold)\").unwrap(),\n/// # \tFont { size: Size(1.0, 1.0), thickness: None, bold: true }\n/// # );\n/// ```\n///\n/// ### Description\n///\n/// For a more detailed description, see [`deserialize_option`].\npub struct OptionDef<T>(PhantomData<T>);\n\nimpl<'de, T> OptionDef<T>\nwhere\n\tT: Deserialize<'de>\n{\n\tpub fn deserialize<D>(deserializer: D) -> Result<Option<T>, D::Error>\n\twhere\n\t\tD: Deserializer<'de>\n\t{\n\t\tdeserialize_option(deserializer)\n\t}\n}\n\nimpl<T> OptionDef<T>\nwhere\n\tOption<T>: Serialize\n{\n\tpub fn serialize<S>(this: &Option<T>, serializer: S) -> Result<S::Ok, S::Error>\n\twhere\n\t\tS: Serializer\n\t{\n\t\tthis.serialize(serializer)\n\t}\n}\n\n/// Deserialize an [`Option`] in a way that is supported by the s-expression format.\n///\n/// ### Example\n///\n/// ```rust\n/// # use serde::{Deserialize, Serialize};\n/// # #[derive(Debug, PartialEq)]\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(deny_unknown_fields, rename = \"size\")]\n/// struct Size(f32, f32);\n///\n/// # #[derive(Debug, PartialEq)]\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(deny_unknown_fields, rename = \"thickness\")]\n/// struct Thickness(f32);\n///\n/// # #[derive(Debug, PartialEq)]\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(deny_unknown_fields, rename = \"font\")]\n/// struct Font {\n/// \tsize: Size,\n///\n/// \t// This attribute enables our custom deserialize logic.\n/// \t#[serde(deserialize_with = \"serde_kicad_sexpr::deserialize_option\")]\n/// \tthickness: Option<Thickness>,\n///\n/// \tbold: bool\n/// }\n/// # assert_eq!(\n/// # \tserde_kicad_sexpr::from_str::<Font>(\"(font (size 1 1) bold)\").unwrap(),\n/// # \tFont { size: Size(1.0, 1.0), thickness: None, bold: true }\n/// # );\n/// ```\n///\n/// ### Description\n///\n/// The s-expression format is not only not self-describing, but also does not provide any way\n/// to see if a value is \"missing\" (i.e. [`None`]) without knowing its type. Unfortunately, serde\n/// expects us to decide if the value is present before we know its type: In the above example,\n/// we have the input string `\"bold)\"` and need to know if `thickness` is present or not, without\n/// knowing that `thickness` is an s-expr and not, say, an enum that has a variant called `bold`.\n///\n/// This custom deserialize logic therefore avoids calling [`Deserializer::deserialize_option`]\n/// alltogether. Instead, we'll try to deserialize the value as if it was present, and return\n/// [`None`] if the deserializer returns an error before calling the visitor. This is likely\n/// indicative of a type error, that would indicate a missing value.\n///\n/// ### Drawbacks\n///\n/// Using this deserialize logic might hide errors in the input. If this optional value\n/// is the last value that gets deserialized, and the deserialization failed due to some\n/// error other than a type error, it might get hidden.\n///\n/// Also, if trying to deserialize the value alters the state of the deserializer, it could\n/// lead to incorrect deserialization.\npub fn deserialize_option<'de, D, T>(deserializer: D) -> Result<Option<T>, D::Error>\nwhere\n\tD: Deserializer<'de>,\n\tT: Deserialize<'de>\n{\n\t// this flag will be set if any visitor method was called\n\tlet mut flag = false;\n\n\t// try to deserialize a present value\n\tlet result = T::deserialize(OptionDeserializer {\n\t\tde: deserializer,\n\t\tflag: &mut flag\n\t});\n\n\t// if the flag is not set and we don't have a value, assume a non-present value\n\tmatch result {\n\t\tOk(value) => Ok(Some(value)),\n\t\tErr(_) if !flag => Ok(None),\n\t\tErr(err) => Err(err)\n\t}\n}\n\n/// A deserializer that intercepts the visitor with our custom visitor.\nstruct OptionDeserializer<'a, D> {\n\tde: D,\n\tflag: &'a mut bool\n}\n\nmacro_rules! forward_deserializer {\n\t($(fn $ident:ident <$visitor:ident>(\n\t\tself,\n\t\t$visitor_arg:ident : $visitor_arg_ty:ty\n\t\t$(, $arg:ident : $arg_ty:ty)*\n\t);)+) => {\n\t\t$(\n\t\t\tfn $ident<$visitor>(\n\t\t\t\tself,\n\t\t\t\t$($arg: $arg_ty,)*\n\t\t\t\t$visitor_arg: $visitor_arg_ty\n\t\t\t) -> Result<$visitor::Value, Self::Error>\n\t\t\twhere\n\t\t\t\t$visitor: Visitor<'de>\n\t\t\t{\n\t\t\t\tlet $visitor_arg = OptionVisitor {\n\t\t\t\t\tvisitor: $visitor_arg,\n\t\t\t\t\tflag: self.flag\n\t\t\t\t};\n\t\t\t\tself.de.$ident($($arg,)* $visitor_arg)\n\t\t\t}\n\t\t)+\n\t};\n}\n\nimpl<'a, 'de, D> Deserializer<'de> for OptionDeserializer<'a, D>\nwhere\n\tD: Deserializer<'de>\n{\n\ttype Error = D::Error;\n\n\tforward_deserializer! {\n\t\tfn deserialize_any<V>(self, visitor: V);\n\t\tfn deserialize_bool<V>(self, visitor: V);\n\t\tfn deserialize_i8<V>(self, visitor: V);\n\t\tfn deserialize_i16<V>(self, visitor: V);\n\t\tfn deserialize_i32<V>(self, visitor: V);\n\t\tfn deserialize_i64<V>(self, visitor: V);\n\t\tfn deserialize_i128<V>(self, visitor: V);\n\t\tfn deserialize_u8<V>(self, visitor: V);\n\t\tfn deserialize_u16<V>(self, visitor: V);\n\t\tfn deserialize_u32<V>(self, visitor: V);\n\t\tfn deserialize_u64<V>(self, visitor: V);\n\t\tfn deserialize_u128<V>(self, visitor: V);\n\t\tfn deserialize_f32<V>(self, visitor: V);\n\t\tfn deserialize_f64<V>(self, visitor: V);\n\t\tfn deserialize_char<V>(self, visitor: V);\n\t\tfn deserialize_str<V>(self, visitor: V);\n\t\tfn deserialize_string<V>(self, visitor: V);\n\t\tfn deserialize_bytes<V>(self, visitor: V);\n\t\tfn deserialize_byte_buf<V>(self, visitor: V);\n\t\tfn deserialize_option<V>(self, visitor: V);\n\t\tfn deserialize_unit<V>(self, visitor: V);\n\t\tfn deserialize_unit_struct<V>(self, visitor: V, name: &'static str);\n\t\tfn deserialize_newtype_struct<V>(self, visitor: V, name: &'static str);\n\t\tfn deserialize_seq<V>(self, visitor: V);\n\t\tfn deserialize_tuple<V>(self, visitor: V, len: usize);\n\t\tfn deserialize_tuple_struct<V>(self, visitor: V, name: &'static str, len: usize);\n\t\tfn deserialize_map<V>(self, visitor: V);\n\t\tfn deserialize_struct<V>(self, visitor: V, name: &'static str, fields: &'static [&'static str]);\n\t\tfn deserialize_enum<V>(self, visitor: V, name: &'static str, variants: &'static [&'static str]);\n\t\tfn deserialize_identifier<V>(self, visitor: V);\n\t\tfn deserialize_ignored_any<V>(self, visitor: V);\n\t}\n\n\tfn is_human_readable(&self) -> bool {\n\t\tself.de.is_human_readable()\n\t}\n}\n\n/// A visitor that will set a flag if any visit method was called (except for visit_none).\n/// This indicates that the value was indeed present, i.e. any error return was not a\n/// general type error but instead a problem deserializing the correct type.\nstruct OptionVisitor<'a, V> {\n\tvisitor: V,\n\tflag: &'a mut bool\n}\n\nmacro_rules! forward_visitor {\n\t($(fn $ident:ident <$error:ident>(self $(, $arg:ident : $arg_ty:ty)*);)+) => {\n\t\t$(\n\t\t\tfn $ident<$error>(self $(, $arg: $arg_ty,)*) -> Result<Self::Value, $error>\n\t\t\twhere\n\t\t\t\t$error: de::Error\n\t\t\t{\n\t\t\t\t*self.flag = true;\n\t\t\t\tself.visitor.$ident($($arg),*)\n\t\t\t}\n\t\t)+\n\t};\n\n\t($(fn $ident:ident <$access:ident : $access_bound:path>(\n\t\tself $(, $arg:ident : $arg_ty:ty)*\n\t);)+) => {\n\t\t$(\n\t\t\tfn $ident<$access>(self $(, $arg: $arg_ty,)*) -> Result<Self::Value, $access::Error>\n\t\t\twhere\n\t\t\t\t$access: $access_bound\n\t\t\t{\n\t\t\t\t*self.flag = true;\n\t\t\t\tself.visitor.$ident($($arg),*)\n\t\t\t}\n\t\t)+\n\t};\n}\n\nimpl<'a, 'de, V> Visitor<'de> for OptionVisitor<'a, V>\nwhere\n\tV: Visitor<'de>\n{\n\ttype Value = V::Value;\n\n\tfn expecting(&self, f: &mut Formatter<'_>) -> fmt::Result {\n\t\tf.write_str(\"optional \")?;\n\t\tself.visitor.expecting(f)\n\t}\n\n\tforward_visitor! {\n\t\tfn visit_bool<E>(self, v: bool);\n\t\tfn visit_i8<E>(self, v: i8);\n\t\tfn visit_i16<E>(self, v: i16);\n\t\tfn visit_i32<E>(self, v: i32);\n\t\tfn visit_i64<E>(self, v: i64);\n\t\tfn visit_i128<E>(self, v: i128);\n\t\tfn visit_u8<E>(self, v: u8);\n\t\tfn visit_u16<E>(self, v: u16);\n\t\tfn visit_u32<E>(self, v: u32);\n\t\tfn visit_u64<E>(self, v: u64);\n\t\tfn visit_u128<E>(self, v: u128);\n\t\tfn visit_f32<E>(self, v: f32);\n\t\tfn visit_f64<E>(self, v: f64);\n\t\tfn visit_char<E>(self, v: char);\n\t\tfn visit_str<E>(self, v: &str);\n\t\tfn visit_borrowed_str<E>(self, v: &'de str);\n\t\tfn visit_string<E>(self, v: String);\n\t\tfn visit_bytes<E>(self, v: &[u8]);\n\t\tfn visit_borrowed_bytes<E>(self, v: &'de [u8]);\n\t\tfn visit_byte_buf<E>(self, v: Vec<u8>);\n\t\tfn visit_unit<E>(self);\n\t}\n\n\tfn visit_none<E>(self) -> Result<Self::Value, E>\n\twhere\n\t\tE: de::Error\n\t{\n\t\t// special case - if we don't set the flag and return an error, we'll\n\t\t// get None\n\t\tErr(E::custom(\"\"))\n\t}\n\n\tforward_visitor! {\n\t\tfn visit_some<D: Deserializer<'de>>(self, de: D);\n\t\tfn visit_newtype_struct<D: Deserializer<'de>>(self, de: D);\n\t\tfn visit_seq<A: SeqAccess<'de>>(self, seq: A);\n\t\tfn visit_map<A: MapAccess<'de>>(self, map: A);\n\t\tfn visit_enum<A: EnumAccess<'de>>(self, data: A);\n\t}\n}\n","traces":[{"line":55,"address":[304112,304464,304560,304240,304336,304400,304208,304656,304624,304272,304688,304176,304304,304528,304432],"length":1,"stats":{"Line":9},"fn_name":"deserialize<test::Drill, serde_kicad_sexpr::de::Field>"},{"line":59,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":67,"address":[304944,304816,305008,304880,304752],"length":1,"stats":{"Line":6},"fn_name":"serialize<(), serde_kicad_sexpr::ser::Field>"},{"line":71,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":130,"address":[308272,305904,310368,306752,309648,308912,307424,309216,308576,305072,306304,307824,307088,309984,305568],"length":1,"stats":{"Line":9},"fn_name":"deserialize_option<serde_kicad_sexpr::de::Field, test::Drill>"},{"line":136,"address":[305920,309664,305584,308592,305089,310384,306768,307841,310000,308289,309233,306321,307440,307104,308929],"length":1,"stats":{"Line":9},"fn_name":null},{"line":139,"address":[307886,310397,309677,307117,308942,305597,306366,310039,308605,309278,305134,307453,305933,306781,308302],"length":1,"stats":{"Line":9},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[312000,311952,312208,312480,312832,313008,312048,312352,312400,312608,312736,312304,312912,312128,312256],"length":1,"stats":{"Line":9},"fn_name":"deserialize_f32<serde_kicad_sexpr::de::MissingField, serde::de::impls::{impl#52}::deserialize::PrimitiveVisitor>"},{"line":173,"address":[312144,312938,312885,311969,312225,312416,313061,312064,312321,312273,312369,312017,312697,312569,312772],"length":1,"stats":{"Line":9},"fn_name":null},{"line":175,"address":[312140,312060,312934,312412,312768],"length":1,"stats":{"Line":5},"fn_name":null},{"line":177,"address":[312777,312022,312421,312890,313066,312326,311974,312149,312574,312374,312230,312278,312702,312069,312943],"length":1,"stats":{"Line":9},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[310832,310960,311696,310768,310896,311648,311744,310704],"length":1,"stats":{"Line":3},"fn_name":"visit_bool<test::_::{impl#0}::deserialize::__Visitor, serde_kicad_sexpr::de::error::Error>"},{"line":243,"address":[310731,310859,311665,310923,310795,310987,311768,311718],"length":1,"stats":{"Line":3},"fn_name":null},{"line":244,"address":[310990,310798,310926,310862,311668,311771,311721,310734],"length":1,"stats":{"Line":3},"fn_name":null},{"line":253,"address":[311872,311792],"length":1,"stats":{"Line":2},"fn_name":"visit_map<test::_::{impl#0}::deserialize::__Visitor, serde_kicad_sexpr::de::SExpr>"},{"line":257,"address":[311916,311824],"length":1,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[311827,311919],"length":1,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[311392,311024,311358,311104,311486,311520,311614,311229,311136,311264],"length":1,"stats":{"Line":4},"fn_name":"visit_none<serde::de::impls::UnitVisitor, serde_kicad_sexpr::de::error::Error>"},{"line":305,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":23,"coverable":30},{"path":["/","home","runner","work","serde_kicad_sexpr","serde_kicad_sexpr","src","private.rs"],"content":"use serde::{\n\tde::{self, Deserializer, Visitor},\n\tforward_to_deserialize_any\n};\nuse std::{\n\terror::Error,\n\tfmt::{self, Debug, Display, Formatter}\n};\n\npub use once_cell::sync::Lazy as SyncLazy;\n\npub struct NameExtractor;\n\n#[derive(Debug)]\npub enum Extraction {\n\tOk(&'static str),\n\tErr(String)\n}\n\nimpl Display for Extraction {\n\tfn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n\t\tmatch self {\n\t\t\tSelf::Ok(ok) => Display::fmt(ok, f),\n\t\t\tSelf::Err(err) => Display::fmt(err, f)\n\t\t}\n\t}\n}\n\nimpl Error for Extraction {}\n\nimpl de::Error for Extraction {\n\tfn custom<T: Display>(msg: T) -> Self {\n\t\tSelf::Err(msg.to_string())\n\t}\n}\n\nimpl<'de> Deserializer<'de> for NameExtractor {\n\ttype Error = Extraction;\n\n\tfn deserialize_any<V>(self, _visitor: V) -> Result<V::Value, Extraction>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tErr(Extraction::Err(\n\t\t\t\"Expected to deserialize a struct\".to_owned()\n\t\t))\n\t}\n\n\tfn deserialize_unit_struct<V>(\n\t\tself,\n\t\tname: &'static str,\n\t\t_visitor: V\n\t) -> Result<V::Value, Extraction>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tErr(Extraction::Ok(name))\n\t}\n\n\tfn deserialize_newtype_struct<V>(\n\t\tself,\n\t\tname: &'static str,\n\t\t_visitor: V\n\t) -> Result<V::Value, Extraction>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tErr(Extraction::Ok(name))\n\t}\n\n\tfn deserialize_tuple_struct<V>(\n\t\tself,\n\t\tname: &'static str,\n\t\t_len: usize,\n\t\t_visitor: V\n\t) -> Result<V::Value, Extraction>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tErr(Extraction::Ok(name))\n\t}\n\n\tfn deserialize_struct<V>(\n\t\tself,\n\t\tname: &'static str,\n\t\t_fields: &'static [&'static str],\n\t\t_visitor: V\n\t) -> Result<V::Value, Extraction>\n\twhere\n\t\tV: Visitor<'de>\n\t{\n\t\tErr(Extraction::Ok(name))\n\t}\n\n\tforward_to_deserialize_any! {\n\t\tbool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string bytes\n\t\tbyte_buf option unit seq tuple map enum identifier ignored_any\n\t}\n}\n","traces":[{"line":21,"address":[161824],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":22,"address":[161847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[161870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[161902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[210672,210737],"length":1,"stats":{"Line":0},"fn_name":"custom<core::fmt::Arguments>"},{"line":33,"address":[210685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[210864,210768],"length":1,"stats":{"Line":2},"fn_name":"deserialize_unit_struct<serde_kicad_sexpr::untagged::tests::foo_bar::_::{impl#0}::deserialize::__Visitor>"},{"line":57,"address":[210885,210789],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":13},{"path":["/","home","runner","work","serde_kicad_sexpr","serde_kicad_sexpr","src","ser","error.rs"],"content":"use serde::ser;\nuse std::fmt::Display;\nuse thiserror::Error;\n\n#[derive(Clone, Debug, Error, PartialEq)]\npub enum Error {\n\t#[error(\"{0}\")]\n\tMessage(String),\n\n\t/// This error will be returned if you request to serialize anything but a struct\n\t/// at root level.\n\t#[error(\"Expected to serialize a struct at root level\")]\n\tExpectedStruct,\n\n\t/// This error will be returned if a boolean was detected in an unnamed\n\t/// container, i.e. a tuple or a sequence.\n\t#[error(\"Unnamed boolean\")]\n\tUnnamedBoolean,\n\n\t/// This error will be returned if a unit was detected in an unnamed container,\n\t/// i.e. a tuple or a sequence.\n\t#[error(\"Unnamed unit\")]\n\tUnnamedUnit,\n\n\t/// This error will be returned if a sequence was detected in an unnamed\n\t/// container, i.e. a tuple or a sequence.\n\t#[error(\"Unnamed sequence\")]\n\tUnnamedSeq,\n\n\t#[error(\"char is unsupported\")]\n\tChar,\n\t#[error(\"byte array is unsupported\")]\n\tBytes,\n\t#[error(\"enums with non-unit variants are not supported\")]\n\tComplexEnum,\n\t#[error(\"maps are not supported\")]\n\tMap\n}\n\nimpl ser::Error for Error {\n\tfn custom<T: Display>(msg: T) -> Self {\n\t\tSelf::Message(msg.to_string())\n\t}\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","runner","work","serde_kicad_sexpr","serde_kicad_sexpr","src","ser","mod.rs"],"content":"use itoa::Integer;\nuse paste::paste;\nuse serde::ser::{\n\tself, Serialize, SerializeSeq, SerializeStruct, SerializeTuple,\n\tSerializeTupleStruct\n};\n\nmod error;\npub use error::Error;\n\npub struct Serializer {\n\t/// Buffer that the output gets written to.\n\tbuf: String,\n\n\t/// Set to true for pretty output.\n\tpretty: bool,\n\n\t/// The current level of nesting\n\tlvl: usize,\n\n\t/// The indentation (in levels) of the current line\n\tindent: usize,\n\n\t/// An itoa::Buffer to re-use when printing integers\n\titoa_buffer: itoa::Buffer\n}\n\nimpl Serializer {\n\tfn new(pretty: bool) -> Self {\n\t\tSelf {\n\t\t\tbuf: String::new(),\n\t\t\tpretty,\n\t\t\tlvl: 0,\n\t\t\tindent: 0,\n\t\t\titoa_buffer: itoa::Buffer::new()\n\t\t}\n\t}\n}\n\ntype Result<T, E = Error> = std::result::Result<T, E>;\n\npub fn to_string<T>(value: &T) -> Result<String>\nwhere\n\tT: ?Sized + Serialize\n{\n\tlet mut serializer = Serializer::new(false);\n\tvalue.serialize(&mut serializer)?;\n\tOk(serializer.buf)\n}\n\npub fn to_string_pretty<T>(value: &T) -> Result<String>\nwhere\n\tT: ?Sized + Serialize\n{\n\tlet mut serializer = Serializer::new(true);\n\tvalue.serialize(&mut serializer)?;\n\tOk(serializer.buf)\n}\n\nimpl Serializer {\n\tfn newline(&mut self) {\n\t\tself.buf += \"\\n\";\n\t\tfor _ in 0..self.lvl {\n\t\t\tself.buf += \"  \";\n\t\t}\n\t\tself.indent = self.lvl;\n\t}\n\n\tfn begin_sexpr(&mut self, name: &str) {\n\t\tif self.lvl > 0 {\n\t\t\tif self.pretty {\n\t\t\t\tself.newline();\n\t\t\t} else {\n\t\t\t\tself.buf += \" \";\n\t\t\t}\n\t\t}\n\t\tself.lvl += 1;\n\t\tself.buf += \"(\";\n\t\tself.buf += name;\n\t}\n\n\tfn end_sexpr(&mut self) {\n\t\tself.lvl -= 1;\n\t\tself.buf += \")\";\n\t}\n\n\tfn write_integer<I: Integer>(&mut self, v: I) {\n\t\tself.buf += \" \";\n\t\tself.buf += self.itoa_buffer.format(v);\n\t}\n\n\tfn write_float<F: ToString>(&mut self, v: F) {\n\t\tself.buf += \" \";\n\t\tself.buf += &v.to_string();\n\t}\n\n\tfn write_str(&mut self, v: &str, aggressive_quotes: bool) {\n\t\tself.buf += \" \";\n\n\t\tconst CHARS: &[char] = &[' ', '\\t', '\\n', '\\r', '(', ')', '\"'];\n\t\tlet need_quotes = v.is_empty()\n\t\t\t|| match aggressive_quotes {\n\t\t\t\ttrue => v.chars().any(|ch| !ch.is_ascii_alphabetic() && ch != '_'),\n\t\t\t\tfalse => v.contains(CHARS)\n\t\t\t};\n\n\t\tif need_quotes {\n\t\t\tself.buf += r#\"\"\"#;\n\t\t\tself.buf += &v.replace('\\\\', r\"\\\\\").replace('\"', r#\"\\\"\"#);\n\t\t\tself.buf += r#\"\"\"#;\n\t\t} else {\n\t\t\tself.buf += v;\n\t\t}\n\t}\n}\n\nmacro_rules! serialize_type_error {\n\t($(fn $ident:ident $(<$T:ident>)? (self $(, $arg_ty:ty)*);)+) => {\n\t\t$(\n\t\t\tfn $ident $(<$T>)? (self $(, _: $arg_ty)*) -> Result<Self::Ok, Self::Error>\n\t\t\t$(where $T: ?Sized + Serialize)?\n\t\t\t{\n\t\t\t\tErr(Error::ExpectedStruct)\n\t\t\t}\n\t\t)+\n\t};\n\n\t($(fn $ident:ident $(<$T:ident>)? (self $(, $arg_ty:ty)*) -> $ret:ty;)+) => {\n\t\t$(\n\t\t\tfn $ident $(<$T>)? (self $(, _: $arg_ty)*) -> $ret\n\t\t\t$(where $T: ?Sized + Serialize)?\n\t\t\t{\n\t\t\t\tErr(Error::ExpectedStruct)\n\t\t\t}\n\t\t)+\n\t};\n\n\t($(fn $ident:ident $(<$T:ident>)? (self $(, $arg_ty:ty)*) = $err:expr;)+) => {\n\t\t$(\n\t\t\tfn $ident $(<$T>)? (self $(, _: $arg_ty)*) -> Result<Self::Ok, Self::Error>\n\t\t\t$(where $T: ?Sized + Serialize)?\n\t\t\t{\n\t\t\t\tErr($err)\n\t\t\t}\n\t\t)+\n\t};\n\n\t($(fn $ident:ident $(<$T:ident>)? (self $(, $arg_ty:ty)*) -> $ret:ty = $err:expr;)+) => {\n\t\t$(\n\t\t\tfn $ident $(<$T>)? (self $(, _: $arg_ty)*) -> $ret\n\t\t\t$(where $T: ?Sized + Serialize)?\n\t\t\t{\n\t\t\t\tErr($err)\n\t\t\t}\n\t\t)+\n\t};\n}\n\ntype Impossible<T = (), E = Error> = serde::ser::Impossible<T, E>;\n\nimpl<'a> ser::Serializer for &'a mut Serializer {\n\ttype Ok = ();\n\ttype Error = Error;\n\n\ttype SerializeSeq = Impossible;\n\ttype SerializeTuple = Impossible;\n\ttype SerializeTupleStruct = Self;\n\ttype SerializeTupleVariant = Impossible;\n\ttype SerializeMap = Impossible;\n\ttype SerializeStruct = Self;\n\ttype SerializeStructVariant = Impossible;\n\n\tserialize_type_error! {\n\t\tfn serialize_bool(self, bool);\n\t\tfn serialize_i8(self, i8);\n\t\tfn serialize_i16(self, i16);\n\t\tfn serialize_i32(self, i32);\n\t\tfn serialize_i64(self, i64);\n\t\tfn serialize_i128(self, i128);\n\t\tfn serialize_u8(self, u8);\n\t\tfn serialize_u16(self, u16);\n\t\tfn serialize_u32(self, u32);\n\t\tfn serialize_u64(self, u64);\n\t\tfn serialize_u128(self, u128);\n\t\tfn serialize_f32(self, f32);\n\t\tfn serialize_f64(self, f64);\n\t\tfn serialize_char(self, char);\n\t\tfn serialize_str(self, &str);\n\t\tfn serialize_bytes(self, &[u8]);\n\t\tfn serialize_none(self);\n\t\tfn serialize_some<T>(self, &T);\n\t\tfn serialize_unit(self);\n\t\tfn serialize_unit_variant(self, &'static str, u32, &'static str);\n\t\tfn serialize_newtype_variant<T>(self, &'static str, u32, &'static str, &T);\n\t}\n\n\tserialize_type_error! {\n\t\tfn serialize_seq(self, Option<usize>) -> Result<Impossible>;\n\t\tfn serialize_tuple(self, usize) -> Result<Impossible>;\n\t\tfn serialize_tuple_variant(self, &'static str, u32, &'static str, usize) -> Result<Impossible>;\n\t\tfn serialize_map(self, Option<usize>) -> Result<Impossible>;\n\t\tfn serialize_struct_variant(self, &'static str, u32, &'static str, usize) -> Result<Impossible>;\n\t}\n\n\tfn serialize_unit_struct(self, name: &'static str) -> Result<()> {\n\t\tself.begin_sexpr(name);\n\t\tself.end_sexpr();\n\t\tOk(())\n\t}\n\n\tfn serialize_newtype_struct<T>(self, name: &'static str, value: &T) -> Result<()>\n\twhere\n\t\tT: ?Sized + Serialize\n\t{\n\t\tself.begin_sexpr(name);\n\t\tvalue.serialize(Field {\n\t\t\tser: &mut *self,\n\t\t\tname: None\n\t\t})?;\n\t\tself.end_sexpr();\n\t\tOk(())\n\t}\n\n\tfn serialize_tuple_struct(\n\t\tself,\n\t\tname: &'static str,\n\t\t_len: usize\n\t) -> Result<Self> {\n\t\tself.begin_sexpr(name);\n\t\tOk(self)\n\t}\n\n\tfn serialize_struct(self, name: &'static str, _len: usize) -> Result<Self> {\n\t\tself.begin_sexpr(name);\n\t\tOk(self)\n\t}\n}\n\nimpl<'a> SerializeTupleStruct for &'a mut Serializer {\n\ttype Ok = ();\n\ttype Error = Error;\n\n\tfn serialize_field<T>(&mut self, value: &T) -> Result<()>\n\twhere\n\t\tT: ?Sized + Serialize\n\t{\n\t\tvalue.serialize(Field {\n\t\t\tser: &mut **self,\n\t\t\tname: None\n\t\t})\n\t}\n\n\tfn end(self) -> Result<()> {\n\t\tself.end_sexpr();\n\t\tOk(())\n\t}\n}\n\nimpl<'a> SerializeStruct for &'a mut Serializer {\n\ttype Ok = ();\n\ttype Error = Error;\n\n\tfn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<()>\n\twhere\n\t\tT: ?Sized + Serialize\n\t{\n\t\t// TODO this should probably not be self\n\t\tvalue.serialize(Field {\n\t\t\tser: &mut **self,\n\t\t\tname: Some(key)\n\t\t})\n\t}\n\n\tfn end(self) -> Result<()> {\n\t\tself.end_sexpr();\n\t\tOk(())\n\t}\n}\n\n/// This serializer will serialize all fields. It needs the field name for booleans and\n/// sequences.\nstruct Field<'a> {\n\tser: &'a mut Serializer,\n\tname: Option<&'static str>\n}\n\nmacro_rules! serialize_integer {\n\t($($integer:ty)+) => {\n\t\t$(\n\t\t\tpaste! {\n\t\t\t\tfn [<serialize_ $integer>](self, v: $integer) -> Result<()> {\n\t\t\t\t\tself.ser.write_integer(v);\n\t\t\t\t\tOk(())\n\t\t\t\t}\n\t\t\t}\n\t\t)+\n\t};\n}\n\nimpl<'a> ser::Serializer for Field<'a> {\n\ttype Ok = ();\n\ttype Error = Error;\n\n\ttype SerializeSeq = Sequence<'a>;\n\ttype SerializeTuple = Sequence<'a>;\n\ttype SerializeTupleStruct = &'a mut Serializer;\n\ttype SerializeTupleVariant = Impossible;\n\ttype SerializeMap = Impossible;\n\ttype SerializeStruct = &'a mut Serializer;\n\ttype SerializeStructVariant = Impossible;\n\n\tserialize_type_error! {\n\t\tfn serialize_char(self, char) = Error::Char;\n\t\tfn serialize_bytes(self, &[u8]) = Error::Bytes;\n\t\tfn serialize_newtype_variant<T>(self, &'static str, u32, &'static str, &T) = Error::ComplexEnum;\n\t}\n\n\tserialize_type_error! {\n\t\tfn serialize_tuple_variant(self, &'static str, u32, &'static str, usize) -> Result<Impossible> = Error::ComplexEnum;\n\t\tfn serialize_map(self, Option<usize>) -> Result<Impossible> = Error::Map;\n\t\tfn serialize_struct_variant(self, &'static str, u32, &'static str, usize) -> Result<Impossible> = Error::ComplexEnum;\n\t}\n\n\tfn serialize_bool(self, v: bool) -> Result<()> {\n\t\tlet name = self.name.ok_or(Error::UnnamedBoolean)?;\n\t\tif v {\n\t\t\tself.serialize_str(name)?;\n\t\t}\n\t\tOk(())\n\t}\n\n\tserialize_integer! {\n\t\ti8 i16 i32 i64 i128 u8 u16 u32 u64 u128\n\t}\n\n\tfn serialize_f32(self, v: f32) -> Result<()> {\n\t\tself.ser.write_float(v);\n\t\tOk(())\n\t}\n\n\tfn serialize_f64(self, v: f64) -> Result<()> {\n\t\tself.ser.write_float(v);\n\t\tOk(())\n\t}\n\n\tfn serialize_str(self, v: &str) -> Result<()> {\n\t\tself.ser.write_str(v, true);\n\t\tOk(())\n\t}\n\n\tfn serialize_none(self) -> Result<()> {\n\t\tOk(())\n\t}\n\n\tfn serialize_some<T>(self, v: &T) -> Result<()>\n\twhere\n\t\tT: ?Sized + Serialize\n\t{\n\t\tv.serialize(self)\n\t}\n\n\tfn serialize_unit(self) -> Result<()> {\n\t\tlet name = self.name.ok_or(Error::UnnamedUnit)?;\n\t\tself.ser.serialize_unit_struct(name)\n\t}\n\n\tfn serialize_unit_struct(self, name: &'static str) -> Result<()> {\n\t\tself.ser.serialize_unit_struct(name)\n\t}\n\n\tfn serialize_unit_variant(\n\t\tself,\n\t\t_name: &'static str,\n\t\t_variant_index: u32,\n\t\tvariant: &'static str\n\t) -> Result<()> {\n\t\tself.ser.write_str(variant, false);\n\t\tOk(())\n\t}\n\n\tfn serialize_newtype_struct<T>(self, name: &'static str, value: &T) -> Result<()>\n\twhere\n\t\tT: ?Sized + Serialize\n\t{\n\t\tself.ser.serialize_newtype_struct(name, value)\n\t}\n\n\tfn serialize_seq(self, _len: Option<usize>) -> Result<Sequence<'a>> {\n\t\tlet name = self.name.ok_or(Error::UnnamedSeq)?;\n\t\tlet close_sexpr = match name {\n\t\t\t\"\" => false,\n\t\t\tname => {\n\t\t\t\tself.ser.begin_sexpr(name);\n\t\t\t\ttrue\n\t\t\t}\n\t\t};\n\t\tOk(Sequence::new(self.ser, close_sexpr))\n\t}\n\n\tfn serialize_tuple(self, len: usize) -> Result<Sequence<'a>> {\n\t\tself.serialize_seq(Some(len))\n\t}\n\n\tfn serialize_tuple_struct(\n\t\tself,\n\t\tname: &'static str,\n\t\tlen: usize\n\t) -> Result<&'a mut Serializer> {\n\t\tself.ser.serialize_tuple_struct(name, len)\n\t}\n\n\tfn serialize_struct(\n\t\tself,\n\t\tname: &'static str,\n\t\tlen: usize\n\t) -> Result<&'a mut Serializer> {\n\t\tself.ser.serialize_struct(name, len)\n\t}\n}\n\n/// A sequence / tuple serializer that optionally closes an s-expr afterwards\nstruct Sequence<'a> {\n\tser: &'a mut Serializer,\n\tclose_sexpr: bool\n}\n\nimpl<'a> Sequence<'a> {\n\tfn new(ser: &'a mut Serializer, close_sexpr: bool) -> Self {\n\t\tSelf { ser, close_sexpr }\n\t}\n}\n\nimpl<'a> SerializeSeq for Sequence<'a> {\n\ttype Ok = ();\n\ttype Error = Error;\n\n\tfn serialize_element<T>(&mut self, value: &T) -> Result<()>\n\twhere\n\t\tT: ?Sized + Serialize\n\t{\n\t\tvalue.serialize(Field {\n\t\t\tser: &mut *self.ser,\n\t\t\tname: None\n\t\t})\n\t}\n\n\tfn end(self) -> Result<()> {\n\t\tif self.close_sexpr {\n\t\t\tself.ser.end_sexpr();\n\t\t}\n\t\tOk(())\n\t}\n}\n\nimpl<'a> SerializeTuple for Sequence<'a> {\n\ttype Ok = ();\n\ttype Error = Error;\n\n\tfn serialize_element<T>(&mut self, value: &T) -> Result<()>\n\twhere\n\t\tT: ?Sized + Serialize\n\t{\n\t\tSerializeSeq::serialize_element(self, value)\n\t}\n\n\tfn end(self) -> Result<()> {\n\t\tSerializeSeq::end(self)\n\t}\n}\n","traces":[{"line":29,"address":[275280,275443],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":31,"address":[275307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[275322],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[406624,407024,408988,409024,408624,409788,409824,407424,409388,409424,406988,407388,410188,407788,407824,408188,408224,408588],"length":1,"stats":{"Line":11},"fn_name":"to_string<test::Footprint>"},{"line":46,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":51,"address":[403424,404191,403824,406191,403391,404991,404224,406591,404591,405791,405024,404624,405424,403024,405824,406224,405391,403791],"length":1,"stats":{"Line":11},"fn_name":"to_string_pretty<test::Position>"},{"line":55,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":61,"address":[275456],"length":1,"stats":{"Line":1},"fn_name":"newline"},{"line":62,"address":[275470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[275492],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[275614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[275596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[275648],"length":1,"stats":{"Line":2},"fn_name":"begin_sexpr"},{"line":70,"address":[275682],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[275720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[275755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[275731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[275794,275694,275771],"length":1,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[275775],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[275839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[275856],"length":1,"stats":{"Line":2},"fn_name":"end_sexpr"},{"line":83,"address":[275921,275869],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[275902],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[206896,207376,206784,206672,207264,207152,207712,207024,207600,207488],"length":1,"stats":{"Line":1},"fn_name":"write_integer<u16>"},{"line":88,"address":[206806,207737,206930,207289,207403,207512,207622,207176,206699,207058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[207648,206726,207430,206962,206832,207203,207763,207539,207090,207315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[208189,207997,208016,207824],"length":1,"stats":{"Line":1},"fn_name":"write_float<f64>"},{"line":93,"address":[207844,208036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[207883,207913,208105,208075],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[276504,275968],"length":1,"stats":{"Line":2},"fn_name":"write_str"},{"line":98,"address":[276029],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[276085,276177,276056],"length":1,"stats":{"Line":4},"fn_name":null},{"line":102,"address":[276079],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[208221,208208],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":104,"address":[276109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[276090],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[276219],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[276256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[276524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[276204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[280432,280144,279840,280368,279536,279984,280064,279696,279408,279904,280288,279328,279168,279472,280208,279248,279616,279776,280496],"length":1,"stats":{"Line":0},"fn_name":"serialize_bool"},{"line":123,"address":[279716,279424,279634,280082,279348,279857,279792,280230,280444,280002,279558,279189,280310,280380,280562,279266,279926,279489,280160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[280976,280704,280624,280768,280896],"length":1,"stats":{"Line":0},"fn_name":"serialize_seq"},{"line":133,"address":[280918,281047,280721,280646,280839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[281168,281104],"length":1,"stats":{"Line":0},"fn_name":"serialize_char"},{"line":143,"address":[281123,281193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[281232,281408,281344],"length":1,"stats":{"Line":0},"fn_name":"serialize_tuple_variant"},{"line":153,"address":[281369,281470,281294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[276560],"length":1,"stats":{"Line":1},"fn_name":"serialize_unit_struct"},{"line":206,"address":[276628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[276638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[276653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[413120,413520],"length":1,"stats":{"Line":2},"fn_name":"serialize_newtype_struct<alloc::string::String>"},{"line":215,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[276672],"length":1,"stats":{"Line":1},"fn_name":"serialize_tuple_struct"},{"line":229,"address":[276743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[276763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[276784],"length":1,"stats":{"Line":2},"fn_name":"serialize_struct"},{"line":234,"address":[276855],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[276875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[415600],"length":1,"stats":{"Line":1},"fn_name":"serialize_field<f32>"},{"line":247,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[276896],"length":1,"stats":{"Line":1},"fn_name":"end"},{"line":254,"address":[276928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[276943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[415488,415376,413920,414704,415040,414032,414480,414144,414368,414928,414816,415152,415264,414256,414592],"length":1,"stats":{"Line":17},"fn_name":"serialize_field<test::Position>"},{"line":268,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":274,"address":[276960],"length":1,"stats":{"Line":1},"fn_name":"end"},{"line":275,"address":[276992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[277007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":291,"address":[281856,281520,281776,281584,281648,281984,282112,281920,282048,281712],"length":1,"stats":{"Line":1},"fn_name":"serialize_i8"},{"line":292,"address":[282080,282162,282013,281941,281744,281875,281826,281605,281539,281677],"length":1,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[281762,281895,282180,281695,281625,282098,281559,281844,282031,281961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[281115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[281185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[281285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[281361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[281461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[277024],"length":1,"stats":{"Line":1},"fn_name":"serialize_bool"},{"line":325,"address":[277065,277207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[277189,277482],"length":1,"stats":{"Line":2},"fn_name":null},{"line":327,"address":[277492,277379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[277356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[277648],"length":1,"stats":{"Line":1},"fn_name":"serialize_f32"},{"line":337,"address":[277667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[277684],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[277696],"length":1,"stats":{"Line":0},"fn_name":"serialize_f64"},{"line":342,"address":[277715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[277732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[277744],"length":1,"stats":{"Line":2},"fn_name":"serialize_str"},{"line":347,"address":[277794],"length":1,"stats":{"Line":2},"fn_name":null},{"line":348,"address":[277817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[277840],"length":1,"stats":{"Line":1},"fn_name":"serialize_none"},{"line":352,"address":[277843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[412656,412496,412416,412336,412576],"length":1,"stats":{"Line":4},"fn_name":"serialize_some<()>"},{"line":359,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":362,"address":[277856],"length":1,"stats":{"Line":1},"fn_name":"serialize_unit"},{"line":363,"address":[278012,277880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[277994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[278160],"length":1,"stats":{"Line":0},"fn_name":"serialize_unit_struct"},{"line":368,"address":[278181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[278208],"length":1,"stats":{"Line":1},"fn_name":"serialize_unit_variant"},{"line":377,"address":[278276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[278296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":381,"address":[412736],"length":1,"stats":{"Line":0},"fn_name":"serialize_newtype_struct<f32>"},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[278320],"length":1,"stats":{"Line":1},"fn_name":"serialize_seq"},{"line":389,"address":[278361,278512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[278707,278482,278660],"length":1,"stats":{"Line":3},"fn_name":null},{"line":392,"address":[278681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[278697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[278750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[278720,278773],"length":1,"stats":{"Line":2},"fn_name":null},{"line":400,"address":[278800],"length":1,"stats":{"Line":2},"fn_name":"serialize_tuple"},{"line":401,"address":[278816],"length":1,"stats":{"Line":2},"fn_name":null},{"line":404,"address":[278896],"length":1,"stats":{"Line":1},"fn_name":"serialize_tuple_struct"},{"line":409,"address":[278923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[278944],"length":1,"stats":{"Line":1},"fn_name":"serialize_struct"},{"line":417,"address":[278971],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[278992],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":437,"address":[412976,412880,412784],"length":1,"stats":{"Line":4},"fn_name":"serialize_element<&test::Pad>"},{"line":441,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":447,"address":[279040],"length":1,"stats":{"Line":1},"fn_name":"end"},{"line":448,"address":[279074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[279104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[279088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":459,"address":[413072],"length":1,"stats":{"Line":2},"fn_name":"serialize_element<f32>"},{"line":463,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":466,"address":[279120],"length":1,"stats":{"Line":2},"fn_name":"end"},{"line":467,"address":[279147],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":124,"coverable":146},{"path":["/","home","runner","work","serde_kicad_sexpr","serde_kicad_sexpr","src","untagged.rs"],"content":"#[macro_export(local_inner_macros)]\nmacro_rules! untagged {\n\t(\n\t\t$(#[$attr:meta])*\n\t\t$vis:vis enum $name:ident {\n\t\t\t$(\n\t\t\t\t$(#[$variant_attr:meta])*\n\t\t\t\t$variant:ident($inner:ty)\n\t\t\t),+\n\t\t}\n\t) => {\n\t\t$(#[$attr])*\n\t\t#[derive(::serde::Serialize)]\n\t\t#[serde(untagged)]\n\t\t$vis enum $name {\n\t\t\t$(\n\t\t\t\t$(#[$variant_attr])*\n\t\t\t\t$variant($inner)\n\t\t\t),+\n\t\t}\n\n\t\timpl<'de> ::serde::Deserialize<'de> for $name\n\t\twhere\n\t\t\t$($inner: ::serde::Deserialize<'de>),*\n\t\t{\n\t\t\tfn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n\t\t\twhere\n\t\t\t\tD: ::serde::Deserializer<'de>\n\t\t\t{\n\t\t\t\tstatic VARIANTS: $crate::private::SyncLazy<\n\t\t\t\t\t::std::result::Result<\n\t\t\t\t\t\t[&'static str; count!($($variant)+)],\n\t\t\t\t\t\t::std::string::String\n\t\t\t\t\t>\n\t\t\t\t> = $crate::private::SyncLazy::new(|| ::std::result::Result::Ok([$({\n\t\t\t\t\tlet extraction = <$inner as ::serde::Deserialize>::deserialize(\n\t\t\t\t\t\t$crate::private::NameExtractor\n\t\t\t\t\t);\n\t\t\t\t\tlet extraction = match extraction {\n\t\t\t\t\t\t::std::result::Result::Ok(_) => ::std::unreachable!(),\n\t\t\t\t\t\t::std::result::Result::Err(e) => e\n\t\t\t\t\t};\n\t\t\t\t\tmatch extraction {\n\t\t\t\t\t\t$crate::private::Extraction::Ok(name) => name,\n\t\t\t\t\t\t$crate::private::Extraction::Err(err) => return Err(err)\n\t\t\t\t\t}\n\t\t\t\t}),+]));\n\t\t\t\tlet variants: &'static [&'static str] = VARIANTS\n\t\t\t\t\t.as_ref()\n\t\t\t\t\t.map_err(|err| <D::Error as ::serde::de::Error>::custom(err))?;\n\n\t\t\t\tstruct Visitor(&'static [&'static str]);\n\n\t\t\t\timpl<'de> ::serde::de::Visitor<'de> for Visitor {\n\t\t\t\t\ttype Value = $name;\n\n\t\t\t\t\tfn expecting(\n\t\t\t\t\t\t&self, f: &mut ::std::fmt::Formatter<'_>\n\t\t\t\t\t) -> ::std::fmt::Result {\n\t\t\t\t\t\t::std::fmt::Display::fmt(&::std::format_args!(\n\t\t\t\t\t\t\t\"any s-expr with a name in {:?}\",\n\t\t\t\t\t\t\tself.0\n\t\t\t\t\t\t), f)\n\t\t\t\t\t}\n\n\t\t\t\t\tfn visit_enum<A>(self, data: A) -> ::std::result::Result<$name, A::Error>\n\t\t\t\t\twhere\n\t\t\t\t\t\tA: ::serde::de::EnumAccess<'de>\n\t\t\t\t\t{\n\t\t\t\t\t\tlet (variant_name, variant): (::std::borrow::Cow<'de, str>, _) =\n\t\t\t\t\t\t\tdata.variant()?;\n\n\t\t\t\t\t\tlet mut i = 0;\n\t\t\t\t\t\t$(\n\t\t\t\t\t\t\tif variant_name == self.0[i] {\n\t\t\t\t\t\t\t\tlet inner: $inner =\n\t\t\t\t\t\t\t\t\t::serde::de::VariantAccess::newtype_variant(variant)?;\n\t\t\t\t\t\t\t\treturn ::std::result::Result::Ok($name::$variant(inner));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\t)+\n\t\t\t\t\t\tlet _ = i;\n\n\t\t\t\t\t\treturn ::std::result::Result::Err(\n\t\t\t\t\t\t\t<A::Error as ::serde::de::Error>::invalid_value(\n\t\t\t\t\t\t\t\t::serde::de::Unexpected::Other(&variant_name),\n\t\t\t\t\t\t\t\t&self\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdeserializer.deserialize_enum(\n\t\t\t\t\t::std::stringify!($name),\n\t\t\t\t\tvariants,\n\t\t\t\t\tVisitor(variants)\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t};\n}\n\n#[macro_export(local_inner_macros)]\n#[doc(hidden)]\nmacro_rules! count {\n\t() => {\n\t\t0\n\t};\n\n\t($x:ident $($xs:ident)*) => {\n\t\t1 + count!($($xs)*)\n\t}\n}\n\n#[cfg(test)]\nmod tests {\n\tmod foo_bar {\n\t\tuse serde::{Deserialize, Serialize};\n\n\t\t#[derive(Debug, Deserialize, PartialEq, Serialize)]\n\t\t#[serde(deny_unknown_fields, rename = \"foo\")]\n\t\tpub(super) struct Foo;\n\n\t\t#[derive(Debug, Deserialize, PartialEq, Serialize)]\n\t\t#[serde(deny_unknown_fields, rename = \"bar\")]\n\t\tpub(super) struct Bar;\n\t}\n\n\tuse foo_bar::{Bar, Foo};\n\n\tuntagged! {\n\t\t#[derive(Debug, PartialEq)]\n\t\tenum FooOrBar {\n\t\t\tFoo(Foo),\n\t\t\tBar(Bar)\n\t\t}\n\t}\n\n\t#[test]\n\tfn deserialize_foo() {\n\t\tlet input = \"(foo)\";\n\t\tlet expected = FooOrBar::Foo(Foo);\n\n\t\tlet parsed: FooOrBar =\n\t\t\tcrate::from_str(input).expect(\"Failed to parse input\");\n\t\tassert_eq!(parsed, expected);\n\t}\n\n\t#[test]\n\tfn deserialize_bar() {\n\t\tlet input = \"(bar)\";\n\t\tlet expected = FooOrBar::Bar(Bar);\n\n\t\tlet parsed: FooOrBar =\n\t\t\tcrate::from_str(input).expect(\"Failed to parse input\");\n\t\tassert_eq!(parsed, expected);\n\t}\n}\n","traces":[{"line":18,"address":[229568,229804,230044,229430,229488,229751,229378,229991],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[214112,214571],"length":1,"stats":{"Line":2},"fn_name":"deserialize<&mut serde_kicad_sexpr::de::Deserializer>"},{"line":35,"address":[215166,214624],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":36,"address":[214649,214815],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[214659,214981],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[215007,214682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[214712,215037],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[214764,215101],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[215134,214780],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[214838,215239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[215229,214973],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[214520,214255,214142],"length":1,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[214592,214608,214529,214425],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}<&mut serde_kicad_sexpr::de::Deserializer>"},{"line":57,"address":[229168],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":60,"address":[229190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[215392,216841],"length":1,"stats":{"Line":2},"fn_name":"visit_enum<serde_kicad_sexpr::de::Enum>"},{"line":70,"address":[215560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[215686,215440],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[215650],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[215662,216195,216268,215870,215775],"length":1,"stats":{"Line":8},"fn_name":null},{"line":77,"address":[216136,216600,216023,215914,216375,216484],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[215989,216450],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[215876,216230,216337,216632,216187,216661],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[216767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[216727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[216703,216645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[214338,214366,214569],"length":1,"stats":{"Line":6},"fn_name":null},{"line":96,"address":[214346],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":20,"coverable":28},{"path":["/","home","runner","work","serde_kicad_sexpr","serde_kicad_sexpr","tests","test.rs"],"content":"use indoc::indoc;\nuse paste::paste;\nuse pretty_assertions::assert_eq;\nuse serde::{de::DeserializeOwned, Deserialize, Serialize};\nuse std::fmt::Debug;\n\nfn assert_eq_parsed<T>(input: &str, expected: &T)\nwhere\n\tT: Debug + DeserializeOwned + PartialEq\n{\n\tlet parsed: T =\n\t\tserde_kicad_sexpr::from_str(input).expect(\"Failed to parse input\");\n\tassert_eq!(&parsed, expected);\n}\n\nfn assert_eq_ugly<T>(input: &T, expected: &str)\nwhere\n\tT: ?Sized + Serialize\n{\n\tlet written =\n\t\tserde_kicad_sexpr::to_string(input).expect(\"Failed to write input\");\n\tassert_eq!(written.as_str(), expected);\n}\n\nfn assert_eq_pretty<T>(input: &T, expected: &str)\nwhere\n\tT: ?Sized + Serialize\n{\n\tlet written =\n\t\tserde_kicad_sexpr::to_string_pretty(input).expect(\"Failed to write input\");\n\tassert_eq!(written.as_str(), expected.trim_end_matches('\\n'));\n}\n\nmacro_rules! test_case {\n\t(name: $name:ident,input: $input:expr,value: $value:expr) => {\n\t\tpaste! {\n\t\t\tconst [<TEST_CASE_INPUT_ $name:upper>]: &str = $input;\n\n\t\t\t#[test]\n\t\t\tfn [<test_deserialize_ $name>]() {\n\t\t\t\tlet value = $value;\n\t\t\t\tassert_eq_parsed([<TEST_CASE_INPUT_ $name:upper>], &value);\n\t\t\t}\n\n\t\t\t#[test]\n\t\t\tfn [<test_serialize_ugly_ $name>]() {\n\t\t\t\tlet value = $value;\n\t\t\t\tassert_eq_ugly(&value, [<TEST_CASE_INPUT_ $name:upper>]);\n\t\t\t}\n\n\t\t\t#[test]\n\t\t\tfn [<test_serialize_pretty_ $name>]() {\n\t\t\t\tlet value = $value;\n\t\t\t\tassert_eq_pretty(&value, [<TEST_CASE_INPUT_ $name:upper>]);\n\t\t\t}\n\t\t}\n\t};\n\n\t(\n\t\tname: $name:ident,input: $input:expr,pretty: $pretty:expr,value: $value:expr\n\t) => {\n\t\tpaste! {\n\t\t\tconst [<TEST_CASE_INPUT_ $name:upper>]: &str = $input;\n\t\t\tconst [<TEST_CASE_PRETTY_ $name:upper>]: &str = $pretty;\n\n\t\t\t#[test]\n\t\t\tfn [<test_deserialize_ugly_ $name>]() {\n\t\t\t\tlet value = $value;\n\t\t\t\tassert_eq_parsed([<TEST_CASE_INPUT_ $name:upper>], &value);\n\t\t\t}\n\n\t\t\t#[test]\n\t\t\tfn [<test_deserialize_pretty_ $name>]() {\n\t\t\t\tlet value = $value;\n\t\t\t\tassert_eq_parsed([<TEST_CASE_PRETTY_ $name:upper>], &value);\n\t\t\t}\n\n\t\t\t#[test]\n\t\t\tfn [<test_serialize_ugly_ $name>]() {\n\t\t\t\tlet value = $value;\n\t\t\t\tassert_eq_ugly(&value, [<TEST_CASE_INPUT_ $name:upper>]);\n\t\t\t}\n\n\t\t\t#[test]\n\t\t\tfn [<test_serialize_pretty_ $name>]() {\n\t\t\t\tlet value = $value;\n\t\t\t\tassert_eq_pretty(&value, [<TEST_CASE_PRETTY_ $name:upper>]);\n\t\t\t}\n\t\t}\n\t};\n}\n\n// ##################################################################################\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(deny_unknown_fields, rename = \"locked\")]\nstruct Locked;\n\ntest_case! {\n\tname: locked,\n\tinput: \"(locked)\",\n\tvalue: Locked\n}\n\n#[test]\nfn test_deserialize_locked_trailing_tokens() {\n\tlet input = \"(locked))\";\n\tlet err = serde_kicad_sexpr::from_str::<Locked>(input).unwrap_err();\n\tassert_eq!(err.kind, serde_kicad_sexpr::de::ErrorKind::TrailingTokens);\n}\n\n// ##################################################################################\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(deny_unknown_fields, rename = \"attr\")]\nstruct Attribute(String);\n\ntest_case! {\n\tname: attr,\n\tinput: \"(attr smd)\",\n\tvalue: Attribute(\"smd\".to_owned())\n}\n\n// ##################################################################################\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(deny_unknown_fields, rename = \"descr\")]\nstruct Description(String);\n\ntest_case! {\n\tname: descr,\n\tinput: r#\"(descr \"Hello \\\"World\\\", this \\\"\\\\\\\" is an amazing backspace! \\\\\")\"#,\n\tvalue: Description(\n\t\tr#\"Hello \"World\", this \"\\\" is an amazing backspace! \\\"#.to_owned()\n\t)\n}\n\n// ##################################################################################\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(deny_unknown_fields, rename = \"at\")]\nstruct Position {\n\tx: f32,\n\ty: f32,\n\t#[serde(with = \"serde_kicad_sexpr::Option\")]\n\trot: Option<i16>\n}\n\ntest_case! {\n\tname: position_without_rot,\n\tinput: \"(at 1.23 -4.56)\",\n\tvalue: Position {\n\t\tx: 1.23,\n\t\ty: -4.56,\n\t\trot: None\n\t}\n}\n\ntest_case! {\n\tname: position_with_rot,\n\tinput: \"(at 1.23 -4.56 -90)\",\n\tvalue: Position {\n\t\tx: 1.23,\n\t\ty: -4.56,\n\t\trot: Some(-90)\n\t}\n}\n\n// ##################################################################################\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(deny_unknown_fields, rename = \"size\")]\nstruct Size(f32, f32);\n\ntest_case! {\n\tname: size,\n\tinput: \"(size 1.23 4.56)\",\n\tvalue: Size(1.23, 4.56)\n}\n\n// ##################################################################################\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(deny_unknown_fields, rename = \"thickness\")]\nstruct Thickness(f32);\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(deny_unknown_fields, rename = \"font\")]\nstruct Font {\n\tsize: Size,\n\n\t#[serde(with = \"serde_kicad_sexpr::Option\")]\n\tthickness: Option<Thickness>,\n\n\tbold: bool\n}\n\ntest_case! {\n\tname: font,\n\tinput: \"(font (size 1.27 1.27))\",\n\tpretty: indoc!(r#\"\n\t\t(font\n\t\t  (size 1.27 1.27))\n\t\"#),\n\tvalue: Font {\n\t\tsize: Size(1.27, 1.27),\n\t\tthickness: None,\n\t\tbold: false\n\t}\n}\n\n// ##################################################################################\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(deny_unknown_fields, rename = \"line\")]\nstruct Line {\n\tstart: (f32, f32),\n\tend: (f32, f32),\n\n\t#[serde(with = \"serde_kicad_sexpr::Option\")]\n\tlocked: Option<()>\n}\n\ntest_case! {\n\tname: line_unlocked,\n\tinput: \"(line (start -2.54 1.27) (end 2.54 1.27))\",\n\tpretty: indoc!(r#\"\n\t\t(line\n\t\t  (start -2.54 1.27)\n\t\t  (end 2.54 1.27))\n\t\"#),\n\tvalue: Line {\n\t\tstart: (-2.54, 1.27),\n\t\tend: (2.54, 1.27),\n\t\tlocked: None\n\t}\n}\n\ntest_case! {\n\tname: line_locked,\n\tinput: \"(line (start -2.54 1.27) (end 2.54 1.27) (locked))\",\n\tpretty: indoc!(r#\"\n\t\t(line\n\t\t  (start -2.54 1.27)\n\t\t  (end 2.54 1.27)\n\t\t  (locked))\n\t\"#),\n\tvalue: Line {\n\t\tstart: (-2.54, 1.27),\n\t\tend: (2.54, 1.27),\n\t\tlocked: Some(())\n\t}\n}\n\n// ##################################################################################\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\nenum PadType {\n\t#[serde(rename = \"thru-hole\")]\n\tThroughHole,\n\n\t#[serde(rename = \"smd\")]\n\tSmd\n}\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(rename_all = \"lowercase\")]\nenum PadShape {\n\tCircle,\n\tRect\n}\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(deny_unknown_fields, rename = \"drill\")]\nstruct Drill {\n\toval: bool,\n\tdrill1: f32,\n\t#[serde(with = \"serde_kicad_sexpr::Option\")]\n\tdrill2: Option<f32>\n}\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(deny_unknown_fields, rename = \"pad\")]\nstruct Pad {\n\tindex: String,\n\tty: PadType,\n\tshape: PadShape,\n\tat: Position,\n\tsize: Size,\n\t#[serde(with = \"serde_kicad_sexpr::Option\")]\n\tdrill: Option<Drill>,\n\tlayers: Vec<String>\n}\n\ntest_case! {\n\tname: pad_without_drill,\n\tinput: r#\"(pad \"1\" smd rect (at 0 0) (size 1.27 1.27) (layers \"F.Cu\"))\"#,\n\tpretty: indoc!(r#\"\n\t\t(pad \"1\" smd rect\n\t\t  (at 0 0)\n\t\t  (size 1.27 1.27)\n\t\t  (layers \"F.Cu\"))\n\t\"#),\n\tvalue: Pad {\n\t\tindex: \"1\".into(),\n\t\tty: PadType::Smd,\n\t\tshape: PadShape::Rect,\n\t\tat: Position {\n\t\t\tx: 0.0,\n\t\t\ty: 0.0,\n\t\t\trot: None\n\t\t},\n\t\tsize: Size(1.27, 1.27),\n\t\tdrill: None,\n\t\tlayers: vec![\"F.Cu\".to_owned()]\n\t}\n}\n\ntest_case! {\n\tname: pad_with_drill,\n\tinput: r#\"(pad \"1\" thru-hole rect (at 0 0) (size 1.27 1.27) (drill 0.635) (layers \"F.Cu\"))\"#,\n\tpretty: indoc!(r#\"\n\t\t(pad \"1\" thru-hole rect\n\t\t  (at 0 0)\n\t\t  (size 1.27 1.27)\n\t\t  (drill 0.635)\n\t\t  (layers \"F.Cu\"))\n\t\"#),\n\tvalue: Pad {\n\t\tindex: \"1\".into(),\n\t\tty: PadType::ThroughHole,\n\t\tshape: PadShape::Rect,\n\t\tat: Position {\n\t\t\tx: 0.0,\n\t\t\ty: 0.0,\n\t\t\trot: None\n\t\t},\n\t\tsize: Size(1.27, 1.27),\n\t\tdrill: Some(Drill {\n\t\t\toval: false,\n\t\t\tdrill1: 0.635,\n\t\t\tdrill2: None\n\t\t}),\n\t\tlayers: vec![\"F.Cu\".to_owned()]\n\t}\n}\n\ntest_case! {\n\tname: pad_with_oval_drill,\n\tinput: r#\"(pad \"1\" thru-hole rect (at 0 0) (size 1.27 1.27) (drill oval 0.635 0.847) (layers \"F.Cu\"))\"#,\n\tpretty: indoc!(r#\"\n\t\t(pad \"1\" thru-hole rect\n\t\t  (at 0 0)\n\t\t  (size 1.27 1.27)\n\t\t  (drill oval 0.635 0.847)\n\t\t  (layers \"F.Cu\"))\n\t\"#),\n\tvalue: Pad {\n\t\tindex: \"1\".into(),\n\t\tty: PadType::ThroughHole,\n\t\tshape: PadShape::Rect,\n\t\tat: Position {\n\t\t\tx: 0.0,\n\t\t\ty: 0.0,\n\t\t\trot: None\n\t\t},\n\t\tsize: Size(1.27, 1.27),\n\t\tdrill: Some(Drill {\n\t\t\toval: true,\n\t\t\tdrill1: 0.635,\n\t\t\tdrill2: Some(0.847)\n\t\t}),\n\t\tlayers: vec![\"F.Cu\".to_owned()]\n\t}\n}\n\n// ##################################################################################\n\n#[derive(Debug, Deserialize, PartialEq, Serialize)]\n#[serde(deny_unknown_fields, rename = \"footprint\")]\nstruct Footprint {\n\tlibrary_link: String,\n\n\t#[serde(default, rename = \"\")]\n\tpads: Vec<Pad>\n}\n\ntest_case! {\n\tname: footprint_without_pads,\n\tinput: r#\"(footprint \"Capacitor_SMD:C_0402\")\"#,\n\tvalue: Footprint {\n\t\tlibrary_link: \"Capacitor_SMD:C_0402\".to_owned(),\n\t\tpads: vec![]\n\t}\n}\n\ntest_case! {\n\tname: footprint_with_one_pad,\n\tinput: r#\"(footprint \"Capacitor_SMD:C_0402\" (pad \"1\" smd rect (at 0 0) (size 1.27 1.27) (layers \"F.Cu\")))\"#,\n\tpretty: indoc!(r#\"\n\t\t(footprint \"Capacitor_SMD:C_0402\"\n\t\t  (pad \"1\" smd rect\n\t\t    (at 0 0)\n\t\t    (size 1.27 1.27)\n\t\t    (layers \"F.Cu\")))\n\t\"#),\n\tvalue: Footprint {\n\t\tlibrary_link: \"Capacitor_SMD:C_0402\".to_owned(),\n\t\tpads: vec![Pad {\n\t\t\tindex: \"1\".into(),\n\t\t\tty: PadType::Smd,\n\t\t\tshape: PadShape::Rect,\n\t\t\tat: Position {\n\t\t\t\tx: 0.0,\n\t\t\t\ty: 0.0,\n\t\t\t\trot: None\n\t\t\t},\n\t\t\tsize: Size(1.27, 1.27),\n\t\t\tdrill: None,\n\t\t\tlayers: vec![\"F.Cu\".to_owned()]\n\t\t}]\n\t}\n}\n\ntest_case! {\n\tname: footprint_with_two_pads,\n\tinput: r#\"(footprint \"Capacitor_SMD:C_0402\" (pad \"1\" smd rect (at 0 0) (size 1.27 1.27) (layers \"F.Cu\")) (pad \"2\" smd rect (at 2.54 0) (size 1.27 1.27) (layers \"F.Cu\")))\"#,\n\tpretty: indoc!(r#\"\n\t\t(footprint \"Capacitor_SMD:C_0402\"\n\t\t  (pad \"1\" smd rect\n\t\t    (at 0 0)\n\t\t    (size 1.27 1.27)\n\t\t    (layers \"F.Cu\"))\n\t\t  (pad \"2\" smd rect\n\t\t    (at 2.54 0)\n\t\t    (size 1.27 1.27)\n\t\t    (layers \"F.Cu\")))\n\t\"#),\n\tvalue: Footprint {\n\t\tlibrary_link: \"Capacitor_SMD:C_0402\".to_owned(),\n\t\tpads: vec![\n\t\t\tPad {\n\t\t\t\tindex: \"1\".into(),\n\t\t\t\tty: PadType::Smd,\n\t\t\t\tshape: PadShape::Rect,\n\t\t\t\tat: Position {\n\t\t\t\t\tx: 0.0,\n\t\t\t\t\ty: 0.0,\n\t\t\t\t\trot: None\n\t\t\t\t},\n\t\t\t\tsize: Size(1.27, 1.27),\n\t\t\t\tdrill: None,\n\t\t\t\tlayers: vec![\"F.Cu\".to_owned()]\n\t\t\t},\n\t\t\tPad {\n\t\t\t\tindex: \"2\".into(),\n\t\t\t\tty: PadType::Smd,\n\t\t\t\tshape: PadShape::Rect,\n\t\t\t\tat: Position {\n\t\t\t\t\tx: 2.54,\n\t\t\t\t\ty: 0.0,\n\t\t\t\t\trot: None\n\t\t\t\t},\n\t\t\t\tsize: Size(1.27, 1.27),\n\t\t\t\tdrill: None,\n\t\t\t\tlayers: vec![\"F.Cu\".to_owned()]\n\t\t\t}\n\t\t]\n\t}\n}\n","traces":[],"covered":0,"coverable":0}]}